#!/usr/bin/env tsx
/**
 * @module setup-aca
 * @description Interactive CLI wizard for deploying the Homepage app to Azure Container Apps.
 *
 * Polls live Azure and GitHub accounts to offer real resource selection with
 * arrow-key navigation and type-to-filter. Replaces the original bash script
 * (`setup-aca.sh`) which required Bash 4+ (`mapfile`) and failed on macOS.
 *
 * @example
 * ```sh
 * npm run setup:aca
 * ```
 *
 * @remarks
 * - Requires `az` CLI (logged in) and `gh` CLI (authenticated)
 * - Saves configuration to `.setup-aca.env` for re-runs
 * - Deploys using `infra/main.bicep` (must exist in repo root)
 */

import { select, input, confirm, Separator } from '@inquirer/prompts';
import * as pc from 'picocolors';
import { createSpinner } from 'nanospinner';
import { execSync, exec, spawn } from 'node:child_process';
import { promisify } from 'node:util';
import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import { resolve } from 'node:path';

const execAsync = promisify(exec);

// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Saved wizard configuration, persisted to `.setup-aca.env`. */
interface Config {
  GITHUB_OWNER: string;
  GITHUB_REPO: string;
  IMAGE_TAG: string;
  AZURE_REGION: string;
  APP_NAME: string;
  RESOURCE_GROUP: string;
  TARGET_PORT: string;
  MIN_REPLICAS: string;
}

/** An Azure region returned by `az account list-locations`. */
interface AzureLocation {
  name: string;
  displayName: string;
}

/** A GitHub repository returned by the GitHub API. */
interface GithubRepo {
  name: string;
  full_name: string;
}

/** A GHCR package version returned by the GitHub API. */
interface GhcrVersion {
  metadata?: { container?: { tags?: string[] } };
}

/** An Azure resource group returned by `az group list`. */
interface ResourceGroup {
  name: string;
  location: string;
}

// â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const CONFIG_FILE = resolve(process.cwd(), '.setup-aca.env');
const BICEP_FILE = resolve(process.cwd(), 'infra/main.bicep');

/** Azure regions listed first for convenience. */
const PREFERRED_REGIONS = [
  'eastus',
  'eastus2',
  'westus2',
  'westus3',
  'centralus',
  'northeurope',
  'westeurope',
  'southeastasia',
  'japaneast',
  'australiaeast',
];

/** Resource providers required for Azure Container Apps. */
const REQUIRED_PROVIDERS = [
  'Microsoft.App',
  'Microsoft.OperationalInsights',
];

// â”€â”€â”€ Config persistence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Loads saved configuration from `.setup-aca.env`.
 * @returns Partial config with any previously saved values.
 */
function loadConfig(): Partial<Config> {
  if (!existsSync(CONFIG_FILE)) return {};
  const content = readFileSync(CONFIG_FILE, 'utf-8');
  const config: Partial<Config> = {};
  for (const line of content.split('\n')) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const eqIndex = trimmed.indexOf('=');
    if (eqIndex === -1) continue;
    const key = trimmed.slice(0, eqIndex).trim();
    const value = trimmed.slice(eqIndex + 1).trim().replace(/^["']|["']$/g, '');
    if (key in ({} as Config) || isConfigKey(key)) {
      (config as Record<string, string>)[key] = value;
    }
  }
  return config;
}

/**
 * Type guard to check if a string is a valid {@link Config} key.
 * @param key - The key to check.
 */
function isConfigKey(key: string): key is keyof Config {
  const validKeys: Array<keyof Config> = [
    'GITHUB_OWNER', 'GITHUB_REPO', 'IMAGE_TAG', 'AZURE_REGION',
    'APP_NAME', 'RESOURCE_GROUP', 'TARGET_PORT', 'MIN_REPLICAS',
  ];
  return validKeys.includes(key as keyof Config);
}

/**
 * Saves the current configuration to `.setup-aca.env`.
 * @param config - The full configuration to persist.
 */
function saveConfig(config: Config): void {
  const lines = [
    '# Azure Container Apps deployment config',
    '# Generated by setup-aca.ts â€” do not edit manually',
    '',
    ...Object.entries(config).map(([k, v]) => `${k}="${v}"`),
    '',
  ];
  writeFileSync(CONFIG_FILE, lines.join('\n'));
}

// â”€â”€â”€ Shell helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Runs a shell command synchronously and returns trimmed stdout.
 * @param cmd - The command to execute.
 * @returns Trimmed stdout output.
 * @throws If the command exits with a non-zero code.
 */
function run(cmd: string): string {
  return execSync(cmd, { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }).trim();
}

/**
 * Runs a shell command synchronously, returning `null` on failure.
 * @param cmd - The command to execute.
 * @returns Trimmed stdout or `null` if the command failed.
 */
function tryRun(cmd: string): string | null {
  try {
    return run(cmd);
  } catch {
    return null;
  }
}

/**
 * Runs a long-running shell command asynchronously with a spinner.
 * @param label - The spinner text to display.
 * @param cmd - The command to execute.
 * @returns Trimmed stdout output.
 * @throws If the command exits with a non-zero code.
 */
async function runWithSpinner(label: string, cmd: string): Promise<string> {
  const spinner = createSpinner(label).start();
  try {
    const { stdout } = await execAsync(cmd);
    spinner.success({ text: label });
    return stdout.trim();
  } catch (err) {
    spinner.error({ text: label });
    throw err;
  }
}

// â”€â”€â”€ Preflight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Verifies that all required CLI tools are installed and authenticated.
 * Exits the process with code 1 if any check fails.
 */
function preflight(): void {
  console.log(pc.bold('\nðŸ” Preflight checks\n'));

  // Check az CLI
  const azVersion = tryRun('az version -o tsv 2>/dev/null | head -1');
  if (!azVersion) {
    console.error(pc.red('âœ— Azure CLI (az) is not installed.'));
    console.error(pc.dim('  Install: https://aka.ms/install-azure-cli'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ' Azure CLI found');

  // Check az login
  const azAccount = tryRun('az account show -o tsv --query name 2>/dev/null');
  if (!azAccount) {
    console.error(pc.red('âœ— Not logged in to Azure. Run: az login'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ` Azure account: ${pc.cyan(azAccount)}`);

  // Check gh CLI
  const ghVersion = tryRun('gh --version 2>/dev/null | head -1');
  if (!ghVersion) {
    console.error(pc.red('âœ— GitHub CLI (gh) is not installed.'));
    console.error(pc.dim('  Install: https://cli.github.com'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ' GitHub CLI found');

  // Check gh auth
  const ghUser = tryRun('gh api user -q .login 2>/dev/null');
  if (!ghUser) {
    console.error(pc.red('âœ— Not logged in to GitHub. Run: gh auth login'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ` GitHub user: ${pc.cyan(ghUser)}`);

  // Check bicep file
  if (!existsSync(BICEP_FILE)) {
    console.error(pc.red(`âœ— Bicep file not found: ${BICEP_FILE}`));
    console.error(pc.dim('  Create infra/main.bicep before running this wizard.'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ' infra/main.bicep found');

  console.log();
}

// â”€â”€â”€ GitHub repo selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select a GitHub repository from their account.
 * Polls the authenticated user's repos via the GitHub API.
 * @param saved - Previously saved config values for defaults.
 * @returns Tuple of `[owner, repoName]`.
 */
async function selectGithubRepo(saved: Partial<Config>): Promise<[string, string]> {
  console.log(pc.bold('ðŸ“¦ GitHub Repository\n'));

  const owner = run('gh api user -q .login');
  const reposJson = run(`gh api users/${owner}/repos --paginate -q '.[].name'`);
  const repos = reposJson.split('\n').filter(Boolean).sort();

  if (repos.length === 0) {
    console.error(pc.red('No repositories found for this GitHub account.'));
    process.exit(1);
  }

  const repo = await select({
    message: 'Select repository:',
    choices: repos.map((r) => ({
      name: r === saved.GITHUB_REPO ? `${r} ${pc.dim('(saved)')}` : r,
      value: r,
    })),
    default: saved.GITHUB_REPO,
  });

  console.log();
  return [owner, repo];
}

// â”€â”€â”€ Image tag selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select a container image tag from GHCR.
 * Falls back to "latest" if no published packages are found.
 * @param owner - GitHub username/org.
 * @param repo - Repository name (used as GHCR package name).
 * @param saved - Previously saved config values for defaults.
 * @returns The selected image tag.
 */
async function selectImageTag(owner: string, repo: string, saved: Partial<Config>): Promise<string> {
  console.log(pc.bold('ðŸ·ï¸  Image Tag\n'));

  // GHCR package names are always lowercase
  const packageName = repo.toLowerCase();

  const versionsRaw = tryRun(
    `gh api "users/${owner}/packages/container/${packageName}/versions" --paginate 2>/dev/null`
  );

  let tags: string[] = [];
  if (versionsRaw) {
    try {
      const versions: GhcrVersion[] = JSON.parse(versionsRaw);
      tags = versions
        .flatMap((v) => v.metadata?.container?.tags ?? [])
        .filter(Boolean);
    } catch {
      // JSON parse failed â€” no tags
    }
  }

  if (tags.length === 0) {
    console.log(pc.dim('  No published container images found. Using "latest".'));
    console.log(pc.dim('  (If you have packages, run: gh auth refresh -s read:packages)'));
    console.log();
    return 'latest';
  }

  // Deduplicate and sort, putting "latest" first
  const uniqueTags = Array.from(new Set(tags)).sort((a, b) => {
    if (a === 'latest') return -1;
    if (b === 'latest') return 1;
    return a.localeCompare(b);
  });

  const tag = await select({
    message: 'Select image tag:',
    choices: uniqueTags.map((t) => ({
      name: t === saved.IMAGE_TAG ? `${t} ${pc.dim('(saved)')}` : t,
      value: t,
    })),
    default: saved.IMAGE_TAG ?? 'latest',
  });

  console.log();
  return tag;
}

// â”€â”€â”€ Azure region selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select an Azure region.
 * Common regions are listed first, separated from the full list.
 * @param saved - Previously saved config values for defaults.
 * @returns The selected Azure region name (e.g. `"eastus"`).
 */
async function selectAzureRegion(saved: Partial<Config>): Promise<string> {
  console.log(pc.bold('ðŸŒ Azure Region\n'));

  const locationsRaw = run('az account list-locations -o json --query "[].{name:name, displayName:displayName}"');
  const locations: AzureLocation[] = JSON.parse(locationsRaw);

  const preferred = locations.filter((l) => PREFERRED_REGIONS.includes(l.name));
  const others = locations
    .filter((l) => !PREFERRED_REGIONS.includes(l.name))
    .sort((a, b) => a.displayName.localeCompare(b.displayName));

  // Sort preferred by the order in PREFERRED_REGIONS
  preferred.sort(
    (a, b) => PREFERRED_REGIONS.indexOf(a.name) - PREFERRED_REGIONS.indexOf(b.name)
  );

  const formatChoice = (loc: AzureLocation) => ({
    name: loc.name === saved.AZURE_REGION
      ? `${loc.displayName} (${loc.name}) ${pc.dim('(saved)')}`
      : `${loc.displayName} (${loc.name})`,
    value: loc.name,
  });

  const region = await select({
    message: 'Select Azure region:',
    choices: [
      ...preferred.map(formatChoice),
      new Separator('â”€â”€ other regions â”€â”€'),
      ...others.map(formatChoice),
    ],
    default: saved.AZURE_REGION ?? 'eastus',
  });

  console.log();
  return region;
}

// â”€â”€â”€ Resource group selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select an existing Azure resource group or create a new one.
 * @param saved - Previously saved config values for defaults.
 * @returns The resource group name.
 */
async function selectResourceGroup(saved: Partial<Config>): Promise<string> {
  const rgRaw = tryRun('az group list -o json --query "[].{name:name, location:location}"');
  let existingGroups: ResourceGroup[] = [];
  if (rgRaw) {
    try {
      existingGroups = JSON.parse(rgRaw);
    } catch {
      // parse failed
    }
  }

  const CREATE_NEW = '__create_new__';

  const choices = [
    { name: pc.green('+ Create new resource group'), value: CREATE_NEW },
    ...(existingGroups.length > 0 ? [new Separator('â”€â”€ existing â”€â”€')] : []),
    ...existingGroups
      .sort((a, b) => a.name.localeCompare(b.name))
      .map((rg) => ({
        name: rg.name === saved.RESOURCE_GROUP
          ? `${rg.name} (${rg.location}) ${pc.dim('(saved)')}`
          : `${rg.name} (${rg.location})`,
        value: rg.name,
      })),
  ];

  const selection = await select({
    message: 'Resource group:',
    choices,
    default: saved.RESOURCE_GROUP,
  });

  if (selection === CREATE_NEW) {
    const name = await input({
      message: 'New resource group name:',
      default: saved.RESOURCE_GROUP,
      validate: (v) => v.trim().length > 0 || 'Name is required',
    });
    return name.trim();
  }

  return selection;
}

// â”€â”€â”€ App configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Collected application configuration from user prompts.
 * Returned by {@link configureApp}.
 */
interface AppConfig {
  appName: string;
  resourceGroup: string;
  targetPort: string;
  minReplicas: string;
}

/**
 * Prompts for app-specific configuration: name, resource group, port, replicas.
 * @param saved - Previously saved config values for defaults.
 * @returns The collected {@link AppConfig}.
 */
async function configureApp(saved: Partial<Config>): Promise<AppConfig> {
  console.log(pc.bold('âš™ï¸  App Configuration\n'));

  const appName = await input({
    message: 'App name:',
    default: saved.APP_NAME ?? 'homepage',
    validate: (v) => v.trim().length > 0 || 'Name is required',
  });

  const resourceGroup = await selectResourceGroup(saved);

  const targetPort = await input({
    message: 'Target port:',
    default: saved.TARGET_PORT ?? '3000',
    validate: (v) => {
      const n = Number(v);
      return (Number.isInteger(n) && n > 0 && n <= 65535) || 'Must be a valid port (1-65535)';
    },
  });

  const minReplicas = await input({
    message: 'Minimum replicas:',
    default: saved.MIN_REPLICAS ?? '0',
    validate: (v) => {
      const n = Number(v);
      return (Number.isInteger(n) && n >= 0) || 'Must be a non-negative integer';
    },
  });

  console.log();
  return { appName: appName.trim(), resourceGroup: resourceGroup.trim(), targetPort, minReplicas };
}

// â”€â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Displays a summary table of the deployment configuration.
 * @param config - The full configuration to display.
 */
function printSummary(config: Config): void {
  console.log(pc.bold('\nðŸ“‹ Deployment Summary\n'));
  const entries: Array<[string, string]> = [
    ['GitHub Owner', config.GITHUB_OWNER],
    ['Repository', config.GITHUB_REPO],
    ['Image Tag', config.IMAGE_TAG],
    ['Azure Region', config.AZURE_REGION],
    ['App Name', config.APP_NAME],
    ['Resource Group', config.RESOURCE_GROUP],
    ['Target Port', config.TARGET_PORT],
    ['Min Replicas', config.MIN_REPLICAS],
  ];

  const maxLabel = Math.max(...entries.map(([l]) => l.length));
  for (const [label, value] of entries) {
    console.log(`  ${pc.dim(label.padEnd(maxLabel))}  ${pc.cyan(value)}`);
  }
  console.log();
}

// â”€â”€â”€ Deploy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Checks whether a resource group already exists in Azure.
 * @param name - The resource group name to check.
 * @returns `true` if the resource group exists.
 */
function resourceGroupExists(name: string): boolean {
  const result = tryRun(`az group exists --name "${name}" 2>/dev/null`);
  return result === 'true';
}

/**
 * Executes the full deployment sequence:
 * 1. Registers required Azure resource providers
 * 2. Creates resource group if it doesn't exist
 * 3. Deploys `infra/main.bicep` with the collected parameters
 * 4. Optionally creates a service principal and sets the `AZURE_CREDENTIALS` GitHub secret
 *
 * @param config - The full deployment configuration.
 */
async function deploy(config: Config): Promise<void> {
  console.log(pc.bold('\nðŸš€ Deploying\n'));

  // Register resource providers
  console.log(pc.dim('  Registering Azure resource providers required for Container Apps...\n'));
  for (const provider of REQUIRED_PROVIDERS) {
    await runWithSpinner(
      `Registering ${provider}`,
      `az provider register --namespace ${provider} --wait`
    );
  }
  console.log();

  // Create resource group if needed
  if (!resourceGroupExists(config.RESOURCE_GROUP)) {
    console.log(pc.dim(`  Creating resource group "${config.RESOURCE_GROUP}" in ${config.AZURE_REGION}...`));
    console.log(pc.dim('  This is the container for all deployed Azure resources.\n'));
    await runWithSpinner(
      `Creating resource group ${config.RESOURCE_GROUP}`,
      `az group create --name "${config.RESOURCE_GROUP}" --location "${config.AZURE_REGION}" -o none`
    );
  } else {
    console.log(pc.green('âœ“') + ` Resource group ${pc.cyan(config.RESOURCE_GROUP)} exists`);
  }
  console.log();

  // Deploy Bicep
  console.log(pc.dim('  Deploying infra/main.bicep â€” this creates or updates:\n'));
  console.log(pc.dim(`    â€¢ ${pc.white('Log Analytics Workspace')}  â†’ ${config.APP_NAME}-logs`));
  console.log(pc.dim(`      Collects container logs and metrics (PerGB2018 SKU, 30-day retention)`));
  console.log(pc.dim(`    â€¢ ${pc.white('Container Apps Environment')}  â†’ ${config.APP_NAME}-env`));
  console.log(pc.dim(`      Managed hosting environment connected to Log Analytics`));
  const containerImage = `ghcr.io/${config.GITHUB_OWNER}/${config.GITHUB_REPO}:${config.IMAGE_TAG}`.toLowerCase();
  console.log(pc.dim(`    â€¢ ${pc.white('Container App')}  â†’ ${config.APP_NAME}`));
  console.log(pc.dim(`      Runs ${containerImage}`));
  console.log(pc.dim(`      HTTPS ingress on port ${config.TARGET_PORT}, ${config.MIN_REPLICAS}â€“10 replicas (HTTP auto-scale)`));
  console.log(pc.dim(`      Resources: 0.25 vCPU, 0.5 Gi memory per replica\n`));

  const deployOutput = await runWithSpinner(
    'Deploying infra/main.bicep',
    [
      `az deployment group create`,
      `--resource-group "${config.RESOURCE_GROUP}"`,
      `--template-file "${BICEP_FILE}"`,
      `--parameters`,
      `appName="${config.APP_NAME}"`,
      `location="${config.AZURE_REGION}"`,
      `containerImage="${containerImage}"`,
      `targetPort=${config.TARGET_PORT}`,
      `minReplicas=${config.MIN_REPLICAS}`,
      `-o json`,
    ].join(' ')
  );

  // Show deployment outputs (FQDN + URL)
  try {
    const result = JSON.parse(deployOutput);
    const outputs = result?.properties?.outputs;
    if (outputs?.url?.value) {
      console.log(`\n  ${pc.green('â†’')} App URL: ${pc.cyan(pc.bold(outputs.url.value))}`);
    }
    if (outputs?.fqdn?.value) {
      console.log(`  ${pc.green('â†’')} FQDN:    ${pc.cyan(outputs.fqdn.value)}`);
    }
  } catch {
    // output parsing failed â€” non-critical
  }

  // Service principal + GitHub secret
  const setupSp = await confirm({
    message: 'Create service principal and set AZURE_CREDENTIALS GitHub secret?',
    default: true,
  });

  if (setupSp) {
    const subscriptionId = run('az account show --query id -o tsv');

    const spJson = await runWithSpinner(
      'Creating service principal',
      [
        `az ad sp create-for-rbac`,
        `--name "github-actions-${config.APP_NAME}"`,
        `--role contributor`,
        `--scopes /subscriptions/${subscriptionId}/resourceGroups/${config.RESOURCE_GROUP}`,
        `--sdk-auth`,
      ].join(' ')
    );

    // Pipe via stdin to avoid shell escaping issues with JSON
    const spinner = createSpinner('Setting AZURE_CREDENTIALS secret').start();
    try {
      await new Promise<void>((resolve, reject) => {
        const child = spawn(
          'gh',
          ['secret', 'set', 'AZURE_CREDENTIALS', '--repo', `${config.GITHUB_OWNER}/${config.GITHUB_REPO}`],
          { stdio: ['pipe', 'pipe', 'pipe'] }
        );
        child.stdin.write(spJson);
        child.stdin.end();
        child.on('close', (code) => (code === 0 ? resolve() : reject(new Error(`gh secret set exited with code ${code}`))));
        child.on('error', reject);
      });
      spinner.success({ text: 'Setting AZURE_CREDENTIALS secret' });
    } catch (err) {
      spinner.error({ text: 'Setting AZURE_CREDENTIALS secret' });
      throw err;
    }
  }

  console.log(pc.bold(pc.green('\nâœ… Deployment complete!\n')));
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Entry point for the setup wizard.
 * Orchestrates the full interactive flow: preflight checks, resource selection,
 * app configuration, config persistence, and deployment.
 */
async function main(): Promise<void> {
  console.log(pc.bold(pc.cyan('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—')));
  console.log(pc.bold(pc.cyan('â•‘   Azure Container Apps Setup Wizard      â•‘')));
  console.log(pc.bold(pc.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n')));

  // Load saved config
  const saved = loadConfig();
  if (Object.keys(saved).length > 0) {
    console.log(pc.dim(`  Loaded saved config from ${CONFIG_FILE}\n`));
  }

  // Step 1: Preflight
  preflight();

  // Step 2: GitHub repo
  const [owner, repo] = await selectGithubRepo(saved);

  // Step 3: Image tag
  const imageTag = await selectImageTag(owner, repo, saved);

  // Step 4: Azure region
  const azureRegion = await selectAzureRegion(saved);

  // Step 5: App configuration
  const appConfig = await configureApp(saved);

  // Build full config
  const config: Config = {
    GITHUB_OWNER: owner,
    GITHUB_REPO: repo,
    IMAGE_TAG: imageTag,
    AZURE_REGION: azureRegion,
    APP_NAME: appConfig.appName,
    RESOURCE_GROUP: appConfig.resourceGroup,
    TARGET_PORT: appConfig.targetPort,
    MIN_REPLICAS: appConfig.minReplicas,
  };

  // Step 6: Save config
  saveConfig(config);
  console.log(pc.dim(`  Config saved to ${CONFIG_FILE}\n`));

  // Step 7: Summary + confirm
  printSummary(config);

  const proceed = await confirm({
    message: 'Deploy now?',
    default: true,
  });

  if (!proceed) {
    console.log(pc.dim('\n  Deployment cancelled. Config saved for next run.\n'));
    return;
  }

  // Step 8: Deploy
  await deploy(config);
}

// â”€â”€â”€ Entry point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main().catch((err) => {
  // Handle Ctrl+C gracefully
  if (err instanceof Error && err.name === 'ExitPromptError') {
    console.log(pc.dim('\n  Cancelled.\n'));
    process.exit(0);
  }
  console.error(pc.red(`\n  Error: ${err instanceof Error ? err.message : String(err)}\n`));
  process.exit(1);
});
