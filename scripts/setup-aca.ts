#!/usr/bin/env tsx
/**
 * @module setup-aca
 * @description Interactive CLI wizard for deploying the Homepage app to Azure Container Apps.
 *
 * Polls live Azure and GitHub accounts to offer real resource selection with
 * arrow-key navigation and type-to-filter. Replaces the original bash script
 * (`setup-aca.sh`) which required Bash 4+ (`mapfile`) and failed on macOS.
 *
 * @example
 * ```sh
 * npm run setup:aca
 * ```
 *
 * @remarks
 * - Requires `az` CLI (logged in) and `gh` CLI (authenticated)
 * - Saves configuration to `.setup-aca.env` for re-runs
 * - Deploys using `infra/main.bicep` (must exist in repo root)
 */

import { select, input, confirm, Separator } from '@inquirer/prompts';
import * as pc from 'picocolors';
import { createSpinner } from 'nanospinner';
import { execSync, exec, spawn } from 'node:child_process';
import { promisify } from 'node:util';
import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import { resolve } from 'node:path';

const execAsync = promisify(exec);

// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Saved wizard configuration, persisted to `.setup-aca.env`. */
interface Config {
  GITHUB_OWNER: string;
  GITHUB_REPO: string;
  IMAGE_TAG: string;
  AZURE_REGION: string;
  APP_NAME: string;
  RESOURCE_GROUP: string;
  TARGET_PORT: string;
  MIN_REPLICAS: string;
  CUSTOM_DOMAIN: string;
  CF_ZONE_ID: string;
}

/** An Azure region returned by `az account list-locations`. */
interface AzureLocation {
  name: string;
  displayName: string;
}

/** A GitHub repository returned by the GitHub API. */
interface GithubRepo {
  name: string;
  full_name: string;
}

/** A GHCR package version returned by the GitHub API. */
interface GhcrVersion {
  metadata?: { container?: { tags?: string[] } };
}

/** An Azure resource group returned by `az group list`. */
interface ResourceGroup {
  name: string;
  location: string;
}

// â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const CONFIG_FILE = resolve(process.cwd(), '.setup-aca.env');
const BICEP_FILE = resolve(process.cwd(), 'infra/main.bicep');

/** Azure regions listed first for convenience. */
const PREFERRED_REGIONS = [
  'eastus',
  'eastus2',
  'westus2',
  'westus3',
  'centralus',
  'northeurope',
  'westeurope',
  'southeastasia',
  'japaneast',
  'australiaeast',
];

/** Resource providers required for Azure Container Apps. */
const REQUIRED_PROVIDERS = [
  'Microsoft.App',
  'Microsoft.OperationalInsights',
];

// â”€â”€â”€ Config persistence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Loads saved configuration from `.setup-aca.env`.
 * @returns Partial config with any previously saved values.
 */
function loadConfig(): Partial<Config> {
  if (!existsSync(CONFIG_FILE)) return {};
  const content = readFileSync(CONFIG_FILE, 'utf-8');
  const config: Partial<Config> = {};
  for (const line of content.split('\n')) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const eqIndex = trimmed.indexOf('=');
    if (eqIndex === -1) continue;
    const key = trimmed.slice(0, eqIndex).trim();
    const value = trimmed.slice(eqIndex + 1).trim().replace(/^["']|["']$/g, '');
    if (key in ({} as Config) || isConfigKey(key)) {
      (config as Record<string, string>)[key] = value;
    }
  }
  return config;
}

/**
 * Type guard to check if a string is a valid {@link Config} key.
 * @param key - The key to check.
 */
function isConfigKey(key: string): key is keyof Config {
  const validKeys: Array<keyof Config> = [
    'GITHUB_OWNER', 'GITHUB_REPO', 'IMAGE_TAG', 'AZURE_REGION',
    'APP_NAME', 'RESOURCE_GROUP', 'TARGET_PORT', 'MIN_REPLICAS',
    'CUSTOM_DOMAIN', 'CF_ZONE_ID',
  ];
  return validKeys.includes(key as keyof Config);
}

/**
 * Saves the current configuration to `.setup-aca.env`.
 * @param config - The full configuration to persist.
 */
function saveConfig(config: Config): void {
  const lines = [
    '# Azure Container Apps deployment config',
    '# Generated by setup-aca.ts â€” do not edit manually',
    '',
    ...Object.entries(config).map(([k, v]) => `${k}="${v}"`),
    '',
  ];
  writeFileSync(CONFIG_FILE, lines.join('\n'));
}

// â”€â”€â”€ Shell helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Runs a shell command synchronously and returns trimmed stdout.
 * @param cmd - The command to execute.
 * @returns Trimmed stdout output.
 * @throws If the command exits with a non-zero code.
 */
function run(cmd: string): string {
  return execSync(cmd, { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }).trim();
}

/**
 * Runs a shell command synchronously, returning `null` on failure.
 * @param cmd - The command to execute.
 * @returns Trimmed stdout or `null` if the command failed.
 */
function tryRun(cmd: string): string | null {
  try {
    return run(cmd);
  } catch {
    return null;
  }
}

/**
 * Runs a long-running shell command asynchronously with a spinner.
 * @param label - The spinner text to display.
 * @param cmd - The command to execute.
 * @returns Trimmed stdout output.
 * @throws If the command exits with a non-zero code.
 */
async function runWithSpinner(label: string, cmd: string): Promise<string> {
  const spinner = createSpinner(label).start();
  try {
    const { stdout } = await execAsync(cmd);
    spinner.success({ text: label });
    return stdout.trim();
  } catch (err) {
    spinner.error({ text: label });
    throw err;
  }
}

// â”€â”€â”€ Azure detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Snapshot of an existing Azure Container App discovered via `az containerapp show`. */
interface DetectedApp {
  image: string;
  targetPort: string;
  minReplicas: string;
  fqdn: string;
  region: string;
  customDomains: string[];
}

/**
 * Queries Azure for a running container app and extracts its current settings.
 * @param appName - The container app name.
 * @param resourceGroup - The resource group name.
 * @returns Detected app settings, or `null` if the app doesn't exist.
 */
function detectExistingApp(appName: string, resourceGroup: string): DetectedApp | null {
  const raw = tryRun(
    `az containerapp show --name "${appName}" -g "${resourceGroup}" -o json 2>/dev/null`
  );
  if (!raw) return null;

  try {
    const app = JSON.parse(raw);
    const container = app.properties?.template?.containers?.[0];
    const ingress = app.properties?.configuration?.ingress;
    const scale = app.properties?.template?.scale;

    return {
      image: container?.image ?? '',
      targetPort: String(ingress?.targetPort ?? ''),
      minReplicas: String(scale?.minReplicas ?? '0'),
      fqdn: ingress?.fqdn ?? '',
      region: app.location ?? '',
      customDomains: (ingress?.customDomains ?? []).map((d: { name: string }) => d.name),
    };
  } catch {
    return null;
  }
}

/**
 * Parses a GHCR image string into owner, repo, and tag.
 * @param image - e.g. `"ghcr.io/kotahusky/homepage:latest"`
 * @returns Parsed components, or `null` if the image doesn't match GHCR format.
 */
function parseGhcrImage(image: string): { owner: string; repo: string; tag: string } | null {
  const match = image.match(/^ghcr\.io\/([^/]+)\/([^:]+):?(.*)$/);
  if (!match) return null;
  return { owner: match[1], repo: match[2], tag: match[3] || 'latest' };
}

// â”€â”€â”€ Preflight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Verifies that all required CLI tools are installed and authenticated.
 * Exits the process with code 1 if any check fails.
 * @returns Whether the Cloudflare `wrangler` CLI is available and authenticated.
 */
function preflight(): boolean {
  console.log(pc.bold('\nðŸ” Preflight checks\n'));

  // Check az CLI
  const azVersion = tryRun('az version -o tsv 2>/dev/null | head -1');
  if (!azVersion) {
    console.error(pc.red('âœ— Azure CLI (az) is not installed.'));
    console.error(pc.dim('  Install: https://aka.ms/install-azure-cli'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ' Azure CLI found');

  // Check az login
  const azAccount = tryRun('az account show -o tsv --query name 2>/dev/null');
  if (!azAccount) {
    console.error(pc.red('âœ— Not logged in to Azure. Run: az login'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ` Azure account: ${pc.cyan(azAccount)}`);

  // Check gh CLI
  const ghVersion = tryRun('gh --version 2>/dev/null | head -1');
  if (!ghVersion) {
    console.error(pc.red('âœ— GitHub CLI (gh) is not installed.'));
    console.error(pc.dim('  Install: https://cli.github.com'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ' GitHub CLI found');

  // Check gh auth
  const ghUser = tryRun('gh api user -q .login 2>/dev/null');
  if (!ghUser) {
    console.error(pc.red('âœ— Not logged in to GitHub. Run: gh auth login'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ` GitHub user: ${pc.cyan(ghUser)}`);

  // Check wrangler CLI (optional â€” DNS step requires it)
  let wranglerAvailable = false;
  const wranglerVersion = tryRun('wrangler --version 2>/dev/null');
  if (!wranglerVersion) {
    console.log(pc.yellow('âš ') + ' Cloudflare Wrangler not found (custom domain step will be skipped)');
    console.log(pc.dim('  Install: brew install cloudflare-wrangler2'));
  } else {
    const wranglerUser = tryRun('wrangler whoami 2>/dev/null');
    if (!wranglerUser || wranglerUser.includes('Not authenticated')) {
      console.log(pc.yellow('âš ') + ' Wrangler found but not authenticated (custom domain step will be skipped)');
      console.log(pc.dim('  Run: wrangler login'));
    } else {
      wranglerAvailable = true;
      console.log(pc.green('âœ“') + ' Cloudflare Wrangler authenticated');
    }
  }

  // Check bicep file
  if (!existsSync(BICEP_FILE)) {
    console.error(pc.red(`âœ— Bicep file not found: ${BICEP_FILE}`));
    console.error(pc.dim('  Create infra/main.bicep before running this wizard.'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ' infra/main.bicep found');

  console.log();
  return wranglerAvailable;
}

// â”€â”€â”€ GitHub repo selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select a GitHub repository from their account.
 * Polls the authenticated user's repos via the GitHub API.
 * @param saved - Previously saved config values for defaults.
 * @returns Tuple of `[owner, repoName]`.
 */
async function selectGithubRepo(saved: Partial<Config>): Promise<[string, string]> {
  console.log(pc.bold('ðŸ“¦ GitHub Repository\n'));

  const owner = run('gh api user -q .login');
  const reposJson = run(`gh api users/${owner}/repos --paginate -q '.[].name'`);
  const repos = reposJson.split('\n').filter(Boolean).sort();

  if (repos.length === 0) {
    console.error(pc.red('No repositories found for this GitHub account.'));
    process.exit(1);
  }

  const repo = await select({
    message: 'Select repository:',
    choices: repos.map((r) => ({
      name: r === saved.GITHUB_REPO ? `${r} ${pc.dim('(saved)')}` : r,
      value: r,
    })),
    default: saved.GITHUB_REPO,
  });

  console.log();
  return [owner, repo];
}

// â”€â”€â”€ Image tag selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select a container image tag from GHCR.
 * Falls back to "latest" if no published packages are found.
 * @param owner - GitHub username/org.
 * @param repo - Repository name (used as GHCR package name).
 * @param saved - Previously saved config values for defaults.
 * @returns The selected image tag.
 */
async function selectImageTag(owner: string, repo: string, saved: Partial<Config>): Promise<string> {
  console.log(pc.bold('ðŸ·ï¸  Image Tag\n'));

  // GHCR package names are always lowercase
  const packageName = repo.toLowerCase();

  const versionsRaw = tryRun(
    `gh api "users/${owner}/packages/container/${packageName}/versions" --paginate 2>/dev/null`
  );

  let tags: string[] = [];
  if (versionsRaw) {
    try {
      const versions: GhcrVersion[] = JSON.parse(versionsRaw);
      tags = versions
        .flatMap((v) => v.metadata?.container?.tags ?? [])
        .filter(Boolean);
    } catch {
      // JSON parse failed â€” no tags
    }
  }

  if (tags.length === 0) {
    console.log(pc.dim('  No published container images found. Using "latest".'));
    console.log(pc.dim('  (If you have packages, run: gh auth refresh -s read:packages)'));
    console.log();
    return 'latest';
  }

  // Deduplicate and sort, putting "latest" first
  const uniqueTags = Array.from(new Set(tags)).sort((a, b) => {
    if (a === 'latest') return -1;
    if (b === 'latest') return 1;
    return a.localeCompare(b);
  });

  const tag = await select({
    message: 'Select image tag:',
    choices: uniqueTags.map((t) => ({
      name: t === saved.IMAGE_TAG ? `${t} ${pc.dim('(saved)')}` : t,
      value: t,
    })),
    default: saved.IMAGE_TAG ?? 'latest',
  });

  console.log();
  return tag;
}

// â”€â”€â”€ Azure region selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select an Azure region.
 * Common regions are listed first, separated from the full list.
 * @param saved - Previously saved config values for defaults.
 * @returns The selected Azure region name (e.g. `"eastus"`).
 */
async function selectAzureRegion(saved: Partial<Config>): Promise<string> {
  console.log(pc.bold('ðŸŒ Azure Region\n'));

  const locationsRaw = run('az account list-locations -o json --query "[].{name:name, displayName:displayName}"');
  const locations: AzureLocation[] = JSON.parse(locationsRaw);

  const preferred = locations.filter((l) => PREFERRED_REGIONS.includes(l.name));
  const others = locations
    .filter((l) => !PREFERRED_REGIONS.includes(l.name))
    .sort((a, b) => a.displayName.localeCompare(b.displayName));

  // Sort preferred by the order in PREFERRED_REGIONS
  preferred.sort(
    (a, b) => PREFERRED_REGIONS.indexOf(a.name) - PREFERRED_REGIONS.indexOf(b.name)
  );

  const formatChoice = (loc: AzureLocation) => ({
    name: loc.name === saved.AZURE_REGION
      ? `${loc.displayName} (${loc.name}) ${pc.dim('(saved)')}`
      : `${loc.displayName} (${loc.name})`,
    value: loc.name,
  });

  const region = await select({
    message: 'Select Azure region:',
    choices: [
      ...preferred.map(formatChoice),
      new Separator('â”€â”€ other regions â”€â”€'),
      ...others.map(formatChoice),
    ],
    default: saved.AZURE_REGION ?? 'eastus',
  });

  console.log();
  return region;
}

// â”€â”€â”€ Resource group selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select an existing Azure resource group or create a new one.
 * @param saved - Previously saved config values for defaults.
 * @returns The resource group name.
 */
async function selectResourceGroup(saved: Partial<Config>): Promise<string> {
  const rgRaw = tryRun('az group list -o json --query "[].{name:name, location:location}"');
  let existingGroups: ResourceGroup[] = [];
  if (rgRaw) {
    try {
      existingGroups = JSON.parse(rgRaw);
    } catch {
      // parse failed
    }
  }

  const CREATE_NEW = '__create_new__';

  const choices = [
    { name: pc.green('+ Create new resource group'), value: CREATE_NEW },
    ...(existingGroups.length > 0 ? [new Separator('â”€â”€ existing â”€â”€')] : []),
    ...existingGroups
      .sort((a, b) => a.name.localeCompare(b.name))
      .map((rg) => ({
        name: rg.name === saved.RESOURCE_GROUP
          ? `${rg.name} (${rg.location}) ${pc.dim('(saved)')}`
          : `${rg.name} (${rg.location})`,
        value: rg.name,
      })),
  ];

  const selection = await select({
    message: 'Resource group:',
    choices,
    default: saved.RESOURCE_GROUP,
  });

  if (selection === CREATE_NEW) {
    const name = await input({
      message: 'New resource group name:',
      default: saved.RESOURCE_GROUP,
      validate: (v) => v.trim().length > 0 || 'Name is required',
    });
    return name.trim();
  }

  return selection;
}

// â”€â”€â”€ App configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Collected application configuration from user prompts.
 * Returned by {@link configureApp}.
 */
interface AppConfig {
  appName: string;
  resourceGroup: string;
  targetPort: string;
  minReplicas: string;
}

/**
 * Prompts for app-specific configuration: name, resource group, port, replicas.
 * @param saved - Previously saved config values for defaults.
 * @returns The collected {@link AppConfig}.
 */
async function configureApp(saved: Partial<Config>): Promise<AppConfig> {
  console.log(pc.bold('âš™ï¸  App Configuration\n'));

  const appName = await input({
    message: 'App name:',
    default: saved.APP_NAME ?? 'homepage',
    validate: (v) => v.trim().length > 0 || 'Name is required',
  });

  const resourceGroup = await selectResourceGroup(saved);

  const targetPort = await input({
    message: 'Target port:',
    default: saved.TARGET_PORT ?? '3000',
    validate: (v) => {
      const n = Number(v);
      return (Number.isInteger(n) && n > 0 && n <= 65535) || 'Must be a valid port (1-65535)';
    },
  });

  const minReplicas = await input({
    message: 'Minimum replicas:',
    default: saved.MIN_REPLICAS ?? '0',
    validate: (v) => {
      const n = Number(v);
      return (Number.isInteger(n) && n >= 0) || 'Must be a non-negative integer';
    },
  });

  console.log();
  return { appName: appName.trim(), resourceGroup: resourceGroup.trim(), targetPort, minReplicas };
}

// â”€â”€â”€ Custom domain configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Cloudflare zone returned by the zones API. */
interface CfZone {
  id: string;
  name: string;
}

/**
 * Extracts the root domain (last two segments) from a hostname.
 * @param hostname - e.g. `"homepage.kotahusky.dev"`
 * @returns e.g. `"kotahusky.dev"`
 */
function rootDomain(hostname: string): string {
  const parts = hostname.split('.');
  return parts.slice(-2).join('.');
}

/**
 * Prompts the user to configure a custom domain via Cloudflare DNS.
 * Resolves the Cloudflare zone ID automatically from the domain name.
 * @param saved - Previously saved config values for defaults.
 * @returns Tuple of `[customDomain, cfZoneId]`, or `['', '']` if skipped.
 */
async function configureCustomDomain(saved: Partial<Config>): Promise<[string, string]> {
  console.log(pc.bold('ðŸŒ Custom Domain\n'));

  const wantsDomain = await confirm({
    message: 'Configure custom domain via Cloudflare?',
    default: !!saved.CUSTOM_DOMAIN,
  });

  if (!wantsDomain) {
    console.log();
    return ['', ''];
  }

  const hostname = await input({
    message: 'Full hostname (e.g. homepage.kotahusky.dev):',
    default: saved.CUSTOM_DOMAIN,
    validate: (v) => {
      const trimmed = v.trim();
      if (!trimmed) return 'Hostname is required';
      if (trimmed.split('.').length < 2) return 'Enter a fully qualified domain name';
      return true;
    },
  });

  const domain = rootDomain(hostname.trim());

  // Try to auto-resolve zone ID via Cloudflare API
  let zoneId = '';
  const spinner = createSpinner(`Resolving Cloudflare zone for ${domain}`).start();
  try {
    const zonesRaw = run(
      `wrangler dns list-zones --search "${domain}" --json 2>/dev/null`
    );
    const zones: CfZone[] = JSON.parse(zonesRaw);
    const match = zones.find((z) => z.name === domain);
    if (match) {
      zoneId = match.id;
      spinner.success({ text: `Zone found: ${pc.cyan(domain)} (${pc.dim(zoneId)})` });
    } else {
      spinner.warn({ text: `Could not auto-resolve zone for ${domain}` });
    }
  } catch {
    spinner.warn({ text: `Could not auto-resolve zone for ${domain}` });
  }

  if (!zoneId) {
    zoneId = await input({
      message: 'Cloudflare Zone ID (find in dashboard â†’ Overview):',
      default: saved.CF_ZONE_ID,
      validate: (v) => v.trim().length > 0 || 'Zone ID is required',
    });
  }

  console.log();
  return [hostname.trim(), zoneId.trim()];
}

// â”€â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Displays a summary table of the deployment configuration.
 * When a detected app is provided, values matching the live deployment are
 * annotated with `(current)` and changed values with `(changed)`.
 * @param config - The full configuration to display.
 * @param detected - Optional detected app for comparison indicators.
 */
function printSummary(config: Config, detected?: DetectedApp | null): void {
  console.log(pc.bold('\nðŸ“‹ Deployment Summary\n'));

  // Build a map of detected values for comparison
  const detectedValues: Record<string, string> = {};
  if (detected) {
    const parsed = parseGhcrImage(detected.image);
    if (parsed) {
      detectedValues['GitHub Owner'] = parsed.owner;
      detectedValues['Repository'] = parsed.repo;
      detectedValues['Image Tag'] = parsed.tag;
    }
    detectedValues['Azure Region'] = detected.region;
    detectedValues['Target Port'] = detected.targetPort;
    detectedValues['Min Replicas'] = detected.minReplicas;
    if (detected.customDomains.length > 0) {
      detectedValues['Custom Domain'] = detected.customDomains[0];
    }
  }

  const entries: Array<[string, string]> = [
    ['GitHub Owner', config.GITHUB_OWNER],
    ['Repository', config.GITHUB_REPO],
    ['Image Tag', config.IMAGE_TAG],
    ['Azure Region', config.AZURE_REGION],
    ['App Name', config.APP_NAME],
    ['Resource Group', config.RESOURCE_GROUP],
    ['Target Port', config.TARGET_PORT],
    ['Min Replicas', config.MIN_REPLICAS],
  ];

  if (config.CUSTOM_DOMAIN) {
    entries.push(['Custom Domain', config.CUSTOM_DOMAIN]);
  }

  const maxLabel = Math.max(...entries.map(([l]) => l.length));
  for (const [label, value] of entries) {
    let indicator = '';
    if (detected && label in detectedValues) {
      indicator = detectedValues[label] === value
        ? pc.dim(' (current)')
        : pc.yellow(' (changed)');
    }
    console.log(`  ${pc.dim(label.padEnd(maxLabel))}  ${pc.cyan(value)}${indicator}`);
  }
  console.log();
}

// â”€â”€â”€ Deploy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Checks whether a resource group already exists in Azure.
 * @param name - The resource group name to check.
 * @returns `true` if the resource group exists.
 */
function resourceGroupExists(name: string): boolean {
  const result = tryRun(`az group exists --name "${name}" 2>/dev/null`);
  return result === 'true';
}

/**
 * Executes the full deployment sequence:
 * 1. Registers required Azure resource providers
 * 2. Creates resource group if it doesn't exist
 * 3. Deploys `infra/main.bicep` with the collected parameters
 * 4. Optionally creates a service principal and sets the `AZURE_CREDENTIALS` GitHub secret
 *
 * @param config - The full deployment configuration.
 */
async function deploy(config: Config): Promise<void> {
  console.log(pc.bold('\nðŸš€ Deploying\n'));

  // Register resource providers (skip if already registered)
  console.log(pc.dim('  Checking Azure resource providers required for Container Apps...\n'));
  for (const provider of REQUIRED_PROVIDERS) {
    const state = tryRun(
      `az provider show --namespace ${provider} -o tsv --query registrationState 2>/dev/null`
    );
    if (state === 'Registered') {
      console.log(`  ${pc.green('âœ“')} ${provider} already registered`);
    } else {
      await runWithSpinner(
        `Registering ${provider}`,
        `az provider register --namespace ${provider} --wait`
      );
    }
  }
  console.log();

  // Create resource group if needed
  if (!resourceGroupExists(config.RESOURCE_GROUP)) {
    console.log(pc.dim(`  Creating resource group "${config.RESOURCE_GROUP}" in ${config.AZURE_REGION}...`));
    console.log(pc.dim('  This is the container for all deployed Azure resources.\n'));
    await runWithSpinner(
      `Creating resource group ${config.RESOURCE_GROUP}`,
      `az group create --name "${config.RESOURCE_GROUP}" --location "${config.AZURE_REGION}" -o none`
    );
  } else {
    console.log(pc.green('âœ“') + ` Resource group ${pc.cyan(config.RESOURCE_GROUP)} exists`);
  }
  console.log();

  // Deploy Bicep
  console.log(pc.dim('  Deploying infra/main.bicep â€” this creates or updates:\n'));
  console.log(pc.dim(`    â€¢ ${pc.white('Log Analytics Workspace')}  â†’ ${config.APP_NAME}-logs`));
  console.log(pc.dim(`      Collects container logs and metrics (PerGB2018 SKU, 30-day retention)`));
  console.log(pc.dim(`    â€¢ ${pc.white('Container Apps Environment')}  â†’ ${config.APP_NAME}-env`));
  console.log(pc.dim(`      Managed hosting environment connected to Log Analytics`));
  const containerImage = `ghcr.io/${config.GITHUB_OWNER}/${config.GITHUB_REPO}:${config.IMAGE_TAG}`.toLowerCase();
  console.log(pc.dim(`    â€¢ ${pc.white('Container App')}  â†’ ${config.APP_NAME}`));
  console.log(pc.dim(`      Runs ${containerImage}`));
  console.log(pc.dim(`      HTTPS ingress on port ${config.TARGET_PORT}, ${config.MIN_REPLICAS}â€“10 replicas (HTTP auto-scale)`));
  console.log(pc.dim(`      Resources: 0.25 vCPU, 0.5 Gi memory per replica\n`));

  const deployOutput = await runWithSpinner(
    'Deploying infra/main.bicep',
    [
      `az deployment group create`,
      `--resource-group "${config.RESOURCE_GROUP}"`,
      `--template-file "${BICEP_FILE}"`,
      `--parameters`,
      `appName="${config.APP_NAME}"`,
      `location="${config.AZURE_REGION}"`,
      `containerImage="${containerImage}"`,
      `targetPort=${config.TARGET_PORT}`,
      `minReplicas=${config.MIN_REPLICAS}`,
      `-o json`,
    ].join(' ')
  );

  // Show deployment outputs (FQDN + URL)
  let fqdn = '';
  try {
    const result = JSON.parse(deployOutput);
    const outputs = result?.properties?.outputs;
    if (outputs?.fqdn?.value) {
      fqdn = outputs.fqdn.value;
    }
    if (outputs?.url?.value) {
      console.log(`\n  ${pc.green('â†’')} App URL:    ${pc.cyan(pc.bold(outputs.url.value))}`);
    }
    if (fqdn) {
      console.log(`  ${pc.green('â†’')} FQDN:       ${pc.cyan(fqdn)}`);
    }
  } catch {
    // output parsing failed â€” non-critical
  }

  // Custom domain: Cloudflare CNAME + ACA binding
  if (config.CUSTOM_DOMAIN && config.CF_ZONE_ID && fqdn) {
    console.log(pc.bold('\nðŸŒ Custom Domain Setup\n'));

    // Step A â€” Cloudflare CNAME (skip if it already points to the right FQDN)
    const subdomain = config.CUSTOM_DOMAIN.split('.').slice(0, -2).join('.') || '@';
    let cnameExists = false;
    try {
      const recordsRaw = tryRun(
        `wrangler dns record list ${config.CF_ZONE_ID} --name "${subdomain}" --json 2>/dev/null`
      );
      if (recordsRaw) {
        const records = JSON.parse(recordsRaw);
        cnameExists = records.some(
          (r: { type: string; content: string }) => r.type === 'CNAME' && r.content === fqdn
        );
      }
    } catch {
      // list failed â€” proceed to create
    }

    if (cnameExists) {
      console.log(`  ${pc.green('âœ“')} CNAME already exists: ${config.CUSTOM_DOMAIN} â†’ ${fqdn}`);
    } else {
      try {
        await runWithSpinner(
          `Creating CNAME ${config.CUSTOM_DOMAIN} â†’ ${fqdn}`,
          `wrangler dns record create ${config.CF_ZONE_ID} --type CNAME --name "${subdomain}" --content "${fqdn}" --proxied true`
        );
      } catch {
        console.log(pc.dim('  CNAME may already exist, continuing...'));
      }
    }

    // Step B â€” ACA custom domain binding (skip if already bound)
    const detectedForDeploy = detectExistingApp(config.APP_NAME, config.RESOURCE_GROUP);
    const domainAlreadyBound = detectedForDeploy?.customDomains.includes(config.CUSTOM_DOMAIN) ?? false;

    if (domainAlreadyBound) {
      console.log(`  ${pc.green('âœ“')} Custom domain already bound: ${config.CUSTOM_DOMAIN}`);
    } else {
      try {
        await runWithSpinner(
          `Adding hostname ${config.CUSTOM_DOMAIN} to container app`,
          `az containerapp hostname add --name "${config.APP_NAME}" -g "${config.RESOURCE_GROUP}" --hostname "${config.CUSTOM_DOMAIN}"`
        );
        await runWithSpinner(
          `Binding TLS certificate for ${config.CUSTOM_DOMAIN}`,
          `az containerapp hostname bind --name "${config.APP_NAME}" -g "${config.RESOURCE_GROUP}" --hostname "${config.CUSTOM_DOMAIN}" --environment "${config.APP_NAME}-env" --validation-method CNAME`
        );
      } catch (err) {
        console.log(pc.yellow('âš ') + ` Custom domain binding failed: ${err instanceof Error ? err.message : String(err)}`);
        console.log(pc.dim('  You may need to configure DNS and retry, or bind manually in the Azure portal.'));
      }
    }

    // Step C â€” Print custom URL
    console.log(`\n  ${pc.green('â†’')} Custom URL: ${pc.cyan(pc.bold(`https://${config.CUSTOM_DOMAIN}`))}`);
  }

  // Service principal + GitHub secret
  const setupSp = await confirm({
    message: 'Create service principal and set AZURE_CREDENTIALS GitHub secret?',
    default: true,
  });

  if (setupSp) {
    const subscriptionId = run('az account show --query id -o tsv');

    const spJson = await runWithSpinner(
      'Creating service principal',
      [
        `az ad sp create-for-rbac`,
        `--name "github-actions-${config.APP_NAME}"`,
        `--role contributor`,
        `--scopes /subscriptions/${subscriptionId}/resourceGroups/${config.RESOURCE_GROUP}`,
        `--sdk-auth`,
      ].join(' ')
    );

    // Pipe via stdin to avoid shell escaping issues with JSON
    const spinner = createSpinner('Setting AZURE_CREDENTIALS secret').start();
    try {
      await new Promise<void>((resolve, reject) => {
        const child = spawn(
          'gh',
          ['secret', 'set', 'AZURE_CREDENTIALS', '--repo', `${config.GITHUB_OWNER}/${config.GITHUB_REPO}`],
          { stdio: ['pipe', 'pipe', 'pipe'] }
        );
        child.stdin.write(spJson);
        child.stdin.end();
        child.on('close', (code) => (code === 0 ? resolve() : reject(new Error(`gh secret set exited with code ${code}`))));
        child.on('error', reject);
      });
      spinner.success({ text: 'Setting AZURE_CREDENTIALS secret' });
    } catch (err) {
      spinner.error({ text: 'Setting AZURE_CREDENTIALS secret' });
      throw err;
    }
  }

  console.log(pc.bold(pc.green('\nâœ… Deployment complete!\n')));
}

// â”€â”€â”€ Prompt flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Runs the full interactive prompt flow (repo, tag, region, app config, domain).
 * Extracted so it can be called from the detection-skip or normal path.
 * @param saved - Saved/merged config values to use as defaults.
 * @param wranglerAvailable - Whether the Cloudflare Wrangler CLI is available.
 * @returns The full collected {@link Config}.
 */
async function runPromptFlow(saved: Partial<Config>, wranglerAvailable: boolean): Promise<Config> {
  const [owner, repo] = await selectGithubRepo(saved);
  const imageTag = await selectImageTag(owner, repo, saved);
  const azureRegion = await selectAzureRegion(saved);
  const appConfig = await configureApp(saved);

  let customDomain = '';
  let cfZoneId = '';
  if (wranglerAvailable) {
    [customDomain, cfZoneId] = await configureCustomDomain(saved);
  }

  return {
    GITHUB_OWNER: owner,
    GITHUB_REPO: repo,
    IMAGE_TAG: imageTag,
    AZURE_REGION: azureRegion,
    APP_NAME: appConfig.appName,
    RESOURCE_GROUP: appConfig.resourceGroup,
    TARGET_PORT: appConfig.targetPort,
    MIN_REPLICAS: appConfig.minReplicas,
    CUSTOM_DOMAIN: customDomain,
    CF_ZONE_ID: cfZoneId,
  };
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Entry point for the setup wizard.
 * Orchestrates the full interactive flow: preflight checks, resource selection,
 * app configuration, config persistence, and deployment.
 */
async function main(): Promise<void> {
  console.log(pc.bold(pc.cyan('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—')));
  console.log(pc.bold(pc.cyan('â•‘   Azure Container Apps Setup Wizard      â•‘')));
  console.log(pc.bold(pc.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n')));

  // Load saved config
  const saved = loadConfig();
  if (Object.keys(saved).length > 0) {
    console.log(pc.dim(`  Loaded saved config from ${CONFIG_FILE}\n`));
  }

  // Step 1: Preflight
  const wranglerAvailable = preflight();

  // Step 2: Detect existing deployment
  let detected: DetectedApp | null = null;
  if (saved.APP_NAME && saved.RESOURCE_GROUP) {
    const spinner = createSpinner('Detecting existing deployment...').start();
    detected = detectExistingApp(saved.APP_NAME, saved.RESOURCE_GROUP);
    if (detected) {
      spinner.success({ text: `Found container app ${pc.cyan(saved.APP_NAME)} in rg ${pc.cyan(saved.RESOURCE_GROUP)} (${detected.region})` });
      console.log(pc.dim(`  Image:    ${detected.image}`));
      console.log(pc.dim(`  Port:     ${detected.targetPort}`));
      console.log(pc.dim(`  Replicas: ${detected.minReplicas}â€“10`));
      if (detected.fqdn) console.log(pc.dim(`  FQDN:     ${detected.fqdn}`));
      if (detected.customDomains.length > 0) {
        console.log(pc.dim(`  Domains:  ${detected.customDomains.join(', ')}`));
      }
      console.log();
    } else {
      spinner.warn({ text: `No existing app found for ${saved.APP_NAME} in ${saved.RESOURCE_GROUP}` });
      console.log();
    }
  }

  let config: Config;

  if (detected) {
    const reuseExisting = await confirm({
      message: 'Use existing deployment settings?',
      default: true,
    });

    if (reuseExisting) {
      // Auto-populate config from detected values
      const parsed = parseGhcrImage(detected.image);
      config = {
        GITHUB_OWNER: parsed?.owner ?? saved.GITHUB_OWNER ?? '',
        GITHUB_REPO: parsed?.repo ?? saved.GITHUB_REPO ?? '',
        IMAGE_TAG: parsed?.tag ?? saved.IMAGE_TAG ?? 'latest',
        AZURE_REGION: detected.region || saved.AZURE_REGION || '',
        APP_NAME: saved.APP_NAME!,
        RESOURCE_GROUP: saved.RESOURCE_GROUP!,
        TARGET_PORT: detected.targetPort || saved.TARGET_PORT || '3000',
        MIN_REPLICAS: detected.minReplicas || saved.MIN_REPLICAS || '0',
        CUSTOM_DOMAIN: detected.customDomains[0] || saved.CUSTOM_DOMAIN || '',
        CF_ZONE_ID: saved.CF_ZONE_ID || '',
      };
    } else {
      // Fall through to prompts, but merge detected values as defaults
      const parsed = parseGhcrImage(detected.image);
      const mergedSaved: Partial<Config> = {
        ...saved,
        GITHUB_OWNER: parsed?.owner ?? saved.GITHUB_OWNER,
        GITHUB_REPO: parsed?.repo ?? saved.GITHUB_REPO,
        IMAGE_TAG: parsed?.tag ?? saved.IMAGE_TAG,
        AZURE_REGION: detected.region || saved.AZURE_REGION,
        TARGET_PORT: detected.targetPort || saved.TARGET_PORT,
        MIN_REPLICAS: detected.minReplicas || saved.MIN_REPLICAS,
        CUSTOM_DOMAIN: detected.customDomains[0] || saved.CUSTOM_DOMAIN,
      };

      config = await runPromptFlow(mergedSaved, wranglerAvailable);
    }
  } else {
    config = await runPromptFlow(saved, wranglerAvailable);
  }

  // Save config
  saveConfig(config);
  console.log(pc.dim(`  Config saved to ${CONFIG_FILE}\n`));

  // Summary + confirm
  printSummary(config, detected);

  const proceed = await confirm({
    message: 'Deploy now?',
    default: true,
  });

  if (!proceed) {
    console.log(pc.dim('\n  Deployment cancelled. Config saved for next run.\n'));
    return;
  }

  // Step 9: Deploy
  await deploy(config);
}

// â”€â”€â”€ Entry point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main().catch((err) => {
  // Handle Ctrl+C gracefully
  if (err instanceof Error && err.name === 'ExitPromptError') {
    console.log(pc.dim('\n  Cancelled.\n'));
    process.exit(0);
  }
  console.error(pc.red(`\n  Error: ${err instanceof Error ? err.message : String(err)}\n`));
  process.exit(1);
});
