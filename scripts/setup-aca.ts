#!/usr/bin/env tsx
/**
 * @module setup-aca
 * @description Interactive CLI wizard for deploying the Homepage app to Azure Container Apps.
 *
 * Polls live Azure and GitHub accounts to offer real resource selection with
 * arrow-key navigation and type-to-filter. Replaces the original bash script
 * (`setup-aca.sh`) which required Bash 4+ (`mapfile`) and failed on macOS.
 *
 * @example
 * ```sh
 * npm run setup:aca
 * ```
 *
 * @remarks
 * - Requires `az` CLI (logged in) and `gh` CLI (authenticated)
 * - Saves configuration to `.setup-aca.env` for re-runs
 * - Deploys using `infra/main.bicep` (must exist in repo root)
 */

import { select, input, confirm, Separator } from '@inquirer/prompts';
import * as pc from 'picocolors';
import { createSpinner } from 'nanospinner';
import { execSync, exec, spawn } from 'node:child_process';
import { promisify } from 'node:util';
import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import { resolve } from 'node:path';

const execAsync = promisify(exec);

// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Saved wizard configuration, persisted to `.setup-aca.env`. */
interface Config {
  GITHUB_OWNER: string;
  GITHUB_REPO: string;
  IMAGE_TAG: string;
  AZURE_REGION: string;
  APP_NAME: string;
  RESOURCE_GROUP: string;
  TARGET_PORT: string;
  MIN_REPLICAS: string;
  MAX_REPLICAS: string;
  CUSTOM_DOMAIN: string;
  CF_ZONE_ID: string;
}

/** An Azure region returned by `az account list-locations`. */
interface AzureLocation {
  name: string;
  displayName: string;
}

/** A GitHub repository returned by the GitHub API. */
interface GithubRepo {
  name: string;
  full_name: string;
}

/** A GHCR package version returned by the GitHub API. */
interface GhcrVersion {
  metadata?: { container?: { tags?: string[] } };
}

/** An Azure resource group returned by `az group list`. */
interface ResourceGroup {
  name: string;
  location: string;
}

// â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const CONFIG_FILE = resolve(process.cwd(), '.setup-aca.env');
const BICEP_FILE = resolve(process.cwd(), 'infra/main.bicep');

/** Azure regions listed first for convenience. */
const PREFERRED_REGIONS = [
  'eastus',
  'eastus2',
  'westus2',
  'westus3',
  'centralus',
  'northeurope',
  'westeurope',
  'southeastasia',
  'japaneast',
  'australiaeast',
];

/** Resource providers required for Azure Container Apps. */
const REQUIRED_PROVIDERS = [
  'Microsoft.App',
  'Microsoft.OperationalInsights',
];

// â”€â”€â”€ Config persistence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Loads saved configuration from `.setup-aca.env`.
 * @returns Partial config with any previously saved values.
 */
function loadConfig(): Partial<Config> {
  if (!existsSync(CONFIG_FILE)) return {};
  const content = readFileSync(CONFIG_FILE, 'utf-8');
  const config: Partial<Config> = {};
  for (const line of content.split('\n')) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const eqIndex = trimmed.indexOf('=');
    if (eqIndex === -1) continue;
    const key = trimmed.slice(0, eqIndex).trim();
    const value = trimmed.slice(eqIndex + 1).trim().replace(/^["']|["']$/g, '');
    if (key in ({} as Config) || isConfigKey(key)) {
      (config as Record<string, string>)[key] = value;
    }
  }
  return config;
}

/**
 * Type guard to check if a string is a valid {@link Config} key.
 * @param key - The key to check.
 */
function isConfigKey(key: string): key is keyof Config {
  const validKeys: Array<keyof Config> = [
    'GITHUB_OWNER', 'GITHUB_REPO', 'IMAGE_TAG', 'AZURE_REGION',
    'APP_NAME', 'RESOURCE_GROUP', 'TARGET_PORT', 'MIN_REPLICAS', 'MAX_REPLICAS',
    'CUSTOM_DOMAIN', 'CF_ZONE_ID',
  ];
  return validKeys.includes(key as keyof Config);
}

/**
 * Saves the current configuration to `.setup-aca.env`.
 * @param config - The full configuration to persist.
 */
function saveConfig(config: Config): void {
  const lines = [
    '# Azure Container Apps deployment config',
    '# Generated by setup-aca.ts â€” do not edit manually',
    '',
    ...Object.entries(config).map(([k, v]) => `${k}="${v}"`),
    '',
  ];
  writeFileSync(CONFIG_FILE, lines.join('\n'));
}

// â”€â”€â”€ Shell helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Runs a shell command synchronously and returns trimmed stdout.
 * @param cmd - The command to execute.
 * @returns Trimmed stdout output.
 * @throws If the command exits with a non-zero code.
 */
function run(cmd: string): string {
  return execSync(cmd, { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }).trim();
}

/**
 * Runs a shell command synchronously, returning `null` on failure.
 * @param cmd - The command to execute.
 * @returns Trimmed stdout or `null` if the command failed.
 */
function tryRun(cmd: string): string | null {
  try {
    return run(cmd);
  } catch {
    return null;
  }
}

/**
 * Runs a long-running shell command asynchronously with a spinner.
 * @param label - The spinner text to display.
 * @param cmd - The command to execute.
 * @returns Trimmed stdout output.
 * @throws If the command exits with a non-zero code.
 */
async function runWithSpinner(label: string, cmd: string): Promise<string> {
  const spinner = createSpinner(label).start();
  try {
    const { stdout } = await execAsync(cmd);
    spinner.success({ text: label });
    return stdout.trim();
  } catch (err) {
    spinner.error({ text: label });
    throw err;
  }
}

// â”€â”€â”€ Cloudflare API helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Cloudflare API token, acquired from env var or user prompt when needed. */
let cfApiToken: string | null = null;

/**
 * Ensures the Cloudflare API token is available. Checks:
 * 1. Already resolved (previous call)
 * 2. CLOUDFLARE_API_TOKEN environment variable
 * 3. Prompts the user interactively
 *
 * Verifies the token works before returning.
 * @param repoSlug - GitHub owner/repo for checking existing secrets.
 * @returns The validated API token.
 */
async function ensureCfApiToken(repoSlug: string): Promise<string> {
  // Already have a validated token
  if (cfApiToken) return cfApiToken;

  // Try environment variable
  let token = process.env.CLOUDFLARE_API_TOKEN ?? '';

  if (!token) {
    // Check if the secret exists in GitHub (can't read value, but can check existence)
    const secretExists = tryRun(
      `gh secret list --repo ${repoSlug} --json name --jq '.[].name' 2>/dev/null`
    )?.split('\n').includes('CLOUDFLARE_API_TOKEN') ?? false;

    if (secretExists) {
      console.log(pc.dim('  CLOUDFLARE_API_TOKEN is set as a GitHub secret but not available locally.\n'));
    }

    console.log(pc.dim('  A Cloudflare API token with Zone:DNS:Edit permission is required.'));
    console.log(pc.dim('  Create one at: https://dash.cloudflare.com/profile/api-tokens\n'));

    token = await input({
      message: 'Cloudflare API token:',
      validate: (v) => v.trim().length > 0 || 'Token is required',
    });
    token = token.trim();
  }

  // Verify the token: get account ID first, then call the account-scoped verify endpoint
  const spinner = createSpinner('Verifying Cloudflare API token...').start();
  try {
    // Get account ID
    const accountsRaw = execSync(
      `curl -sS "https://api.cloudflare.com/client/v4/accounts" -H "Authorization: Bearer $CF_TOKEN"`,
      { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'], env: { ...process.env, CF_TOKEN: token } }
    );
    const accountsResp = JSON.parse(accountsRaw);
    const accountId = accountsResp.result?.[0]?.id;
    if (!accountId) {
      spinner.error({ text: 'Cloudflare API token verification failed' });
      const errMsg = accountsResp.errors?.map((e: { message: string }) => e.message).join(', ') || 'no account found';
      throw new Error(`Could not resolve Cloudflare account: ${errMsg}`);
    }

    // Verify token against the account
    const verifyRaw = execSync(
      `curl -sS "https://api.cloudflare.com/client/v4/accounts/${accountId}/tokens/verify" -H "Authorization: Bearer $CF_TOKEN"`,
      { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'], env: { ...process.env, CF_TOKEN: token } }
    );
    const verifyResp = JSON.parse(verifyRaw);
    if (verifyResp.success && verifyResp.result?.status === 'active') {
      spinner.success({ text: `Cloudflare API token verified (account: ${accountsResp.result[0].name})` });
    } else {
      const errMsg = verifyResp.errors?.map((e: { message: string }) => e.message).join(', ') || 'token not active';
      spinner.error({ text: 'Cloudflare API token verification failed' });
      throw new Error(`Cloudflare token is not active: ${errMsg}`);
    }
  } catch (err) {
    if (err instanceof Error && (err.message.includes('Cloudflare token') || err.message.includes('Cloudflare account'))) throw err;
    spinner.error({ text: 'Cloudflare API token verification failed' });
    const msg = err instanceof Error ? err.message : String(err);
    throw new Error(
      `Could not verify Cloudflare API token: ${msg.replace(/Bearer [^\s"]+/g, 'Bearer ***')}\n` +
      '  Make sure you\'re using an API Token (not Global API Key).\n' +
      '  Create one at: https://dash.cloudflare.com/profile/api-tokens'
    );
  }

  cfApiToken = token;
  return token;
}

/**
 * Calls the Cloudflare API. Uses environment variable for the token to avoid
 * leaking it in error messages or process listings.
 * @param method - HTTP method.
 * @param path - API path (e.g. `/zones`).
 * @param body - Optional JSON body.
 * @returns Parsed JSON response.
 */
function cfApi(method: string, path: string, body?: Record<string, unknown>): unknown {
  const args = [
    `curl -sS --fail-with-body -X ${method}`,
    `"https://api.cloudflare.com/client/v4${path}"`,
    `-H "Authorization: Bearer $CF_TOKEN"`,
    `-H "Content-Type: application/json"`,
  ];
  if (body) {
    args.push(`-d '${JSON.stringify(body)}'`);
  }
  const raw = execSync(args.join(' '), {
    encoding: 'utf-8',
    stdio: ['pipe', 'pipe', 'pipe'],
    env: { ...process.env, CF_TOKEN: cfApiToken ?? '' },
  }).trim();
  return JSON.parse(raw);
}

/** Options for creating or updating a Cloudflare DNS record. */
interface DnsRecordOpts {
  type: 'CNAME' | 'TXT';
  name: string;
  content: string;
  proxied: boolean;
  displayName: string;
}

/**
 * Creates, updates, or skips a Cloudflare DNS record via the REST API.
 * - If a record of the same type and name exists with the correct content â†’ skip.
 * - If it exists with different content â†’ update in place.
 * - If it doesn't exist â†’ create.
 * @param zoneId - Cloudflare zone ID.
 * @param opts - Record options.
 */
async function upsertDnsRecord(zoneId: string, opts: DnsRecordOpts): Promise<void> {
  const { type, name, content, proxied, displayName } = opts;

  // Cloudflare API expects the fully-qualified record name for lookups
  // Look up existing records matching this name (any type â€” catch conflicts like A vs CNAME)
  let existingId: string | null = null;
  let existingContent: string | null = null;
  let existingType: string | null = null;
  try {
    const resp = cfApi('GET', `/zones/${zoneId}/dns_records?name=${encodeURIComponent(displayName)}`) as {
      result?: Array<{ id: string; content: string; type: string }>;
    };
    // Prefer exact type match; otherwise take the first conflicting record
    const exactMatch = resp.result?.find((r) => r.type === type);
    const anyMatch = resp.result?.[0];
    const match = exactMatch ?? anyMatch;
    if (match) {
      existingId = match.id;
      existingContent = match.content;
      existingType = match.type;
    }
  } catch {
    // list failed â€” fall through to create
  }

  if (existingId && existingType === type && existingContent === content) {
    console.log(`  ${pc.green('âœ“')} ${type} ${displayName} already correct`);
    return;
  }

  // Use the full domain name for the record (Cloudflare resolves it relative to the zone)
  const recordBody = { type, name: displayName, content, proxied, ttl: 1 };

  if (existingId) {
    // If existing record is a different type (e.g. A â†’ CNAME), delete it first
    if (existingType && existingType !== type) {
      console.log(`  ${pc.yellow('âš ')} Replacing ${existingType} record with ${type} for ${displayName}`);
      await cfApiAsync(
        `Deleting conflicting ${existingType} ${displayName}`,
        'DELETE', `/zones/${zoneId}/dns_records/${existingId}`
      );
      await cfApiAsync(
        `Creating ${type} ${displayName} â†’ ${content}`,
        'POST', `/zones/${zoneId}/dns_records`, recordBody
      );
    } else {
      await cfApiAsync(
        `Updating ${type} ${displayName} â†’ ${content}`,
        'PUT', `/zones/${zoneId}/dns_records/${existingId}`, recordBody
      );
    }
  } else {
    await cfApiAsync(
      `Creating ${type} ${displayName} â†’ ${content}`,
      'POST', `/zones/${zoneId}/dns_records`, recordBody
    );
  }
}

/**
 * Calls the Cloudflare API asynchronously with a spinner. Token is passed
 * via environment variable to avoid leaking in error output.
 */
async function cfApiAsync(
  label: string, method: string, path: string,
  body?: Record<string, unknown>,
): Promise<string> {
  const args = [
    `curl -sS -X ${method}`,
    `"https://api.cloudflare.com/client/v4${path}"`,
    `-H "Authorization: Bearer $CF_TOKEN"`,
    `-H "Content-Type: application/json"`,
  ];
  if (body) {
    args.push(`-d '${JSON.stringify(body)}'`);
  }
  const cmd = args.join(' ');
  const spinner = createSpinner(label).start();
  try {
    const { stdout } = await execAsync(cmd, {
      env: { ...process.env, CF_TOKEN: cfApiToken ?? '' },
    });
    const resp = JSON.parse(stdout);
    if (!resp.success) {
      const errors = (resp.errors ?? []).map((e: { message: string; code?: number }) =>
        e.code ? `${e.message} (code ${e.code})` : e.message
      ).join('; ');
      spinner.error({ text: label });
      throw new Error(`Cloudflare API error: ${errors}`);
    }
    spinner.success({ text: label });
    return stdout.trim();
  } catch (err) {
    if (err instanceof Error && err.message.startsWith('Cloudflare API error:')) throw err;
    spinner.error({ text: label });
    const msg = err instanceof Error ? err.message : String(err);
    throw new Error(msg.replace(/Bearer [^\s"]+/g, 'Bearer ***'));
  }
}

/**
 * Lists Cloudflare zones matching a domain name.
 * @param domain - The root domain to search for.
 * @returns Matching zones.
 */
function listCfZones(domain: string): CfZone[] {
  try {
    const resp = cfApi('GET', `/zones?name=${encodeURIComponent(domain)}`) as {
      result?: CfZone[];
    };
    return resp.result ?? [];
  } catch {
    return [];
  }
}

// â”€â”€â”€ Azure detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Snapshot of an existing Azure Container App discovered via `az containerapp show`. */
interface DetectedApp {
  image: string;
  targetPort: string;
  minReplicas: string;
  maxReplicas: string;
  fqdn: string;
  region: string;
  customDomains: string[];
}

/**
 * Queries Azure for a running container app and extracts its current settings.
 * @param appName - The container app name.
 * @param resourceGroup - The resource group name.
 * @returns Detected app settings, or `null` if the app doesn't exist.
 */
function detectExistingApp(appName: string, resourceGroup: string): DetectedApp | null {
  const raw = tryRun(
    `az containerapp show --name "${appName}" -g "${resourceGroup}" -o json 2>/dev/null`
  );
  if (!raw) return null;

  try {
    const app = JSON.parse(raw);
    const container = app.properties?.template?.containers?.[0];
    const ingress = app.properties?.configuration?.ingress;
    const scale = app.properties?.template?.scale;

    return {
      image: container?.image ?? '',
      targetPort: String(ingress?.targetPort ?? ''),
      minReplicas: String(scale?.minReplicas ?? '0'),
      maxReplicas: String(scale?.maxReplicas ?? '2'),
      fqdn: ingress?.fqdn ?? '',
      region: app.location ?? '',
      customDomains: (ingress?.customDomains ?? []).map((d: { name: string }) => d.name),
    };
  } catch {
    return null;
  }
}

/**
 * Parses a GHCR image string into owner, repo, and tag.
 * @param image - e.g. `"ghcr.io/kotahusky/homepage:latest"`
 * @returns Parsed components, or `null` if the image doesn't match GHCR format.
 */
function parseGhcrImage(image: string): { owner: string; repo: string; tag: string } | null {
  const match = image.match(/^ghcr\.io\/([^/]+)\/([^:]+):?(.*)$/);
  if (!match) return null;
  return { owner: match[1], repo: match[2], tag: match[3] || 'latest' };
}

// â”€â”€â”€ Preflight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Verifies that all required CLI tools are installed and authenticated.
 * Exits the process with code 1 if any check fails.
 */
function preflight(): void {
  console.log(pc.bold('\nğŸ” Preflight checks\n'));

  // Check az CLI
  const azVersion = tryRun('az version -o tsv 2>/dev/null | head -1');
  if (!azVersion) {
    console.error(pc.red('âœ— Azure CLI (az) is not installed.'));
    console.error(pc.dim('  Install: https://aka.ms/install-azure-cli'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ' Azure CLI found');

  // Check az login
  const azAccount = tryRun('az account show -o tsv --query name 2>/dev/null');
  if (!azAccount) {
    console.error(pc.red('âœ— Not logged in to Azure. Run: az login'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ` Azure account: ${pc.cyan(azAccount)}`);

  // Check gh CLI
  const ghVersion = tryRun('gh --version 2>/dev/null | head -1');
  if (!ghVersion) {
    console.error(pc.red('âœ— GitHub CLI (gh) is not installed.'));
    console.error(pc.dim('  Install: https://cli.github.com'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ' GitHub CLI found');

  // Check gh auth
  const ghUser = tryRun('gh api user -q .login 2>/dev/null');
  if (!ghUser) {
    console.error(pc.red('âœ— Not logged in to GitHub. Run: gh auth login'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ` GitHub user: ${pc.cyan(ghUser)}`);

  // Check bicep file
  if (!existsSync(BICEP_FILE)) {
    console.error(pc.red(`âœ— Bicep file not found: ${BICEP_FILE}`));
    console.error(pc.dim('  Create infra/main.bicep before running this wizard.'));
    process.exit(1);
  }
  console.log(pc.green('âœ“') + ' infra/main.bicep found');

  console.log();
}

// â”€â”€â”€ GitHub repo selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select a GitHub repository from their account.
 * Polls the authenticated user's repos via the GitHub API.
 * @param saved - Previously saved config values for defaults.
 * @returns Tuple of `[owner, repoName]`.
 */
async function selectGithubRepo(saved: Partial<Config>): Promise<[string, string]> {
  console.log(pc.bold('ğŸ“¦ GitHub Repository\n'));

  const owner = run('gh api user -q .login');
  const reposJson = run(`gh api users/${owner}/repos --paginate -q '.[].name'`);
  const repos = reposJson.split('\n').filter(Boolean).sort();

  if (repos.length === 0) {
    console.error(pc.red('No repositories found for this GitHub account.'));
    process.exit(1);
  }

  const repo = await select({
    message: 'Select repository:',
    choices: repos.map((r) => ({
      name: r === saved.GITHUB_REPO ? `${r} ${pc.dim('(saved)')}` : r,
      value: r,
    })),
    default: saved.GITHUB_REPO,
  });

  console.log();
  return [owner, repo];
}

// â”€â”€â”€ Image tag selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select a container image tag from GHCR.
 * Falls back to "latest" if no published packages are found.
 * @param owner - GitHub username/org.
 * @param repo - Repository name (used as GHCR package name).
 * @param saved - Previously saved config values for defaults.
 * @returns The selected image tag.
 */
async function selectImageTag(owner: string, repo: string, saved: Partial<Config>): Promise<string> {
  console.log(pc.bold('ğŸ·ï¸  Image Tag\n'));

  // GHCR package names are always lowercase
  const packageName = repo.toLowerCase();

  const versionsRaw = tryRun(
    `gh api "users/${owner}/packages/container/${packageName}/versions" --paginate 2>/dev/null`
  );

  let tags: string[] = [];
  if (versionsRaw) {
    try {
      const versions: GhcrVersion[] = JSON.parse(versionsRaw);
      tags = versions
        .flatMap((v) => v.metadata?.container?.tags ?? [])
        .filter(Boolean);
    } catch {
      // JSON parse failed â€” no tags
    }
  }

  if (tags.length === 0) {
    console.log(pc.dim('  No published container images found. Using "latest".'));
    console.log(pc.dim('  (If you have packages, run: gh auth refresh -s read:packages)'));
    console.log();
    return 'latest';
  }

  // Deduplicate and sort, putting "latest" first
  const uniqueTags = Array.from(new Set(tags)).sort((a, b) => {
    if (a === 'latest') return -1;
    if (b === 'latest') return 1;
    return a.localeCompare(b);
  });

  const tag = await select({
    message: 'Select image tag:',
    choices: uniqueTags.map((t) => ({
      name: t === saved.IMAGE_TAG ? `${t} ${pc.dim('(saved)')}` : t,
      value: t,
    })),
    default: saved.IMAGE_TAG ?? 'latest',
  });

  console.log();
  return tag;
}

// â”€â”€â”€ Azure region selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select an Azure region.
 * Common regions are listed first, separated from the full list.
 * @param saved - Previously saved config values for defaults.
 * @returns The selected Azure region name (e.g. `"eastus"`).
 */
async function selectAzureRegion(saved: Partial<Config>): Promise<string> {
  console.log(pc.bold('ğŸŒ Azure Region\n'));

  const locationsRaw = run('az account list-locations -o json --query "[].{name:name, displayName:displayName}"');
  const locations: AzureLocation[] = JSON.parse(locationsRaw);

  const preferred = locations.filter((l) => PREFERRED_REGIONS.includes(l.name));
  const others = locations
    .filter((l) => !PREFERRED_REGIONS.includes(l.name))
    .sort((a, b) => a.displayName.localeCompare(b.displayName));

  // Sort preferred by the order in PREFERRED_REGIONS
  preferred.sort(
    (a, b) => PREFERRED_REGIONS.indexOf(a.name) - PREFERRED_REGIONS.indexOf(b.name)
  );

  const formatChoice = (loc: AzureLocation) => ({
    name: loc.name === saved.AZURE_REGION
      ? `${loc.displayName} (${loc.name}) ${pc.dim('(saved)')}`
      : `${loc.displayName} (${loc.name})`,
    value: loc.name,
  });

  const region = await select({
    message: 'Select Azure region:',
    choices: [
      ...preferred.map(formatChoice),
      new Separator('â”€â”€ other regions â”€â”€'),
      ...others.map(formatChoice),
    ],
    default: saved.AZURE_REGION ?? 'eastus',
  });

  console.log();
  return region;
}

// â”€â”€â”€ Resource group selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Prompts the user to select an existing Azure resource group or create a new one.
 * @param saved - Previously saved config values for defaults.
 * @returns The resource group name.
 */
async function selectResourceGroup(saved: Partial<Config>): Promise<string> {
  const rgRaw = tryRun('az group list -o json --query "[].{name:name, location:location}"');
  let existingGroups: ResourceGroup[] = [];
  if (rgRaw) {
    try {
      existingGroups = JSON.parse(rgRaw);
    } catch {
      // parse failed
    }
  }

  const CREATE_NEW = '__create_new__';

  const choices = [
    { name: pc.green('+ Create new resource group'), value: CREATE_NEW },
    ...(existingGroups.length > 0 ? [new Separator('â”€â”€ existing â”€â”€')] : []),
    ...existingGroups
      .sort((a, b) => a.name.localeCompare(b.name))
      .map((rg) => ({
        name: rg.name === saved.RESOURCE_GROUP
          ? `${rg.name} (${rg.location}) ${pc.dim('(saved)')}`
          : `${rg.name} (${rg.location})`,
        value: rg.name,
      })),
  ];

  const selection = await select({
    message: 'Resource group:',
    choices,
    default: saved.RESOURCE_GROUP,
  });

  if (selection === CREATE_NEW) {
    const name = await input({
      message: 'New resource group name:',
      default: saved.RESOURCE_GROUP,
      validate: (v) => v.trim().length > 0 || 'Name is required',
    });
    return name.trim();
  }

  return selection;
}

// â”€â”€â”€ App configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Collected application configuration from user prompts.
 * Returned by {@link configureApp}.
 */
interface AppConfig {
  appName: string;
  resourceGroup: string;
  targetPort: string;
  minReplicas: string;
  maxReplicas: string;
}

/**
 * Prompts for app-specific configuration: name, resource group, port, replicas.
 * @param saved - Previously saved config values for defaults.
 * @returns The collected {@link AppConfig}.
 */
async function configureApp(saved: Partial<Config>): Promise<AppConfig> {
  console.log(pc.bold('âš™ï¸  App Configuration\n'));

  const appName = await input({
    message: 'App name:',
    default: saved.APP_NAME ?? 'homepage',
    validate: (v) => v.trim().length > 0 || 'Name is required',
  });

  const resourceGroup = await selectResourceGroup(saved);

  const targetPort = await input({
    message: 'Target port:',
    default: saved.TARGET_PORT ?? '3000',
    validate: (v) => {
      const n = Number(v);
      return (Number.isInteger(n) && n > 0 && n <= 65535) || 'Must be a valid port (1-65535)';
    },
  });

  const minReplicas = await input({
    message: 'Minimum replicas:',
    default: saved.MIN_REPLICAS ?? '0',
    validate: (v) => {
      const n = Number(v);
      return (Number.isInteger(n) && n >= 0) || 'Must be a non-negative integer';
    },
  });

  const maxReplicas = await input({
    message: 'Maximum replicas:',
    default: saved.MAX_REPLICAS ?? '2',
    validate: (v) => {
      const n = Number(v);
      if (!Number.isInteger(n) || n < 1) return 'Must be a positive integer';
      if (n < Number(minReplicas)) return `Must be â‰¥ min replicas (${minReplicas})`;
      return true;
    },
  });

  console.log();
  return { appName: appName.trim(), resourceGroup: resourceGroup.trim(), targetPort, minReplicas, maxReplicas };
}

// â”€â”€â”€ Custom domain configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Cloudflare zone returned by the zones API. */
interface CfZone {
  id: string;
  name: string;
}

/**
 * Extracts the root domain (last two segments) from a hostname.
 * @param hostname - e.g. `"homepage.kotahusky.dev"`
 * @returns e.g. `"kotahusky.dev"`
 */
function rootDomain(hostname: string): string {
  const parts = hostname.split('.');
  return parts.slice(-2).join('.');
}

/**
 * Prompts the user to configure a custom domain via Cloudflare DNS.
 * Resolves the Cloudflare zone ID automatically from the domain name.
 * @param saved - Previously saved config values for defaults.
 * @returns Tuple of `[customDomain, cfZoneId]`, or `['', '']` if skipped.
 */
async function configureCustomDomain(saved: Partial<Config>, repoSlug: string): Promise<[string, string]> {
  console.log(pc.bold('ğŸŒ Custom Domain\n'));

  const wantsDomain = await confirm({
    message: 'Configure custom domain via Cloudflare?',
    default: !!saved.CUSTOM_DOMAIN,
  });

  if (!wantsDomain) {
    console.log();
    return ['', ''];
  }

  const hostname = await input({
    message: 'Full hostname (e.g. homepage.kotahusky.dev):',
    default: saved.CUSTOM_DOMAIN,
    validate: (v) => {
      const trimmed = v.trim();
      if (!trimmed) return 'Hostname is required';
      if (trimmed.split('.').length < 2) return 'Enter a fully qualified domain name';
      return true;
    },
  });

  const domain = rootDomain(hostname.trim());

  // Ensure we have a CF token before looking up the zone
  await ensureCfApiToken(repoSlug);

  // Try to auto-resolve zone ID via Cloudflare API
  let zoneId = '';
  const spinner = createSpinner(`Resolving Cloudflare zone for ${domain}`).start();
  try {
    const zones = listCfZones(domain);
    const match = zones.find((z) => z.name === domain);
    if (match) {
      zoneId = match.id;
      spinner.success({ text: `Zone found: ${pc.cyan(domain)} (${pc.dim(zoneId)})` });
    } else {
      spinner.warn({ text: `Could not auto-resolve zone for ${domain}` });
    }
  } catch {
    spinner.warn({ text: `Could not auto-resolve zone for ${domain}` });
  }

  if (!zoneId) {
    zoneId = await input({
      message: 'Cloudflare Zone ID (find in dashboard â†’ Overview):',
      default: saved.CF_ZONE_ID,
      validate: (v) => v.trim().length > 0 || 'Zone ID is required',
    });
  }

  console.log();
  return [hostname.trim(), zoneId.trim()];
}

// â”€â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Displays a summary table of the deployment configuration.
 * When a detected app is provided, values matching the live deployment are
 * annotated with `(current)` and changed values with `(changed)`.
 * @param config - The full configuration to display.
 * @param detected - Optional detected app for comparison indicators.
 */
function printSummary(config: Config, detected?: DetectedApp | null): void {
  console.log(pc.bold('\nğŸ“‹ Deployment Summary\n'));

  // Build a map of detected values for comparison
  const detectedValues: Record<string, string> = {};
  if (detected) {
    const parsed = parseGhcrImage(detected.image);
    if (parsed) {
      detectedValues['GitHub Owner'] = parsed.owner;
      detectedValues['Repository'] = parsed.repo;
      detectedValues['Image Tag'] = parsed.tag;
    }
    detectedValues['Azure Region'] = detected.region;
    detectedValues['Target Port'] = detected.targetPort;
    detectedValues['Min Replicas'] = detected.minReplicas;
    detectedValues['Max Replicas'] = detected.maxReplicas;
    if (detected.customDomains.length > 0) {
      detectedValues['Custom Domain'] = detected.customDomains[0];
    }
  }

  const entries: Array<[string, string]> = [
    ['GitHub Owner', config.GITHUB_OWNER],
    ['Repository', config.GITHUB_REPO],
    ['Image Tag', config.IMAGE_TAG],
    ['Azure Region', config.AZURE_REGION],
    ['App Name', config.APP_NAME],
    ['Resource Group', config.RESOURCE_GROUP],
    ['Target Port', config.TARGET_PORT],
    ['Min Replicas', config.MIN_REPLICAS],
    ['Max Replicas', config.MAX_REPLICAS],
  ];

  if (config.CUSTOM_DOMAIN) {
    entries.push(['Custom Domain', config.CUSTOM_DOMAIN]);
  }

  const maxLabel = Math.max(...entries.map(([l]) => l.length));
  for (const [label, value] of entries) {
    let indicator = '';
    if (detected && label in detectedValues) {
      indicator = detectedValues[label] === value
        ? pc.dim(' (current)')
        : pc.yellow(' (changed)');
    }
    console.log(`  ${pc.dim(label.padEnd(maxLabel))}  ${pc.cyan(value)}${indicator}`);
  }
  console.log();
}

// â”€â”€â”€ Deploy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Checks whether a resource group already exists in Azure.
 * @param name - The resource group name to check.
 * @returns `true` if the resource group exists.
 */
function resourceGroupExists(name: string): boolean {
  const result = tryRun(`az group exists --name "${name}" 2>/dev/null`);
  return result === 'true';
}

/**
 * Executes the full deployment sequence:
 * 1. Registers required Azure resource providers
 * 2. Creates resource group if it doesn't exist
 * 3. Deploys `infra/main.bicep` with the collected parameters
 * 4. Optionally creates OIDC federated credentials and sets GitHub secrets
 *
 * @param config - The full deployment configuration.
 */
async function deploy(config: Config): Promise<void> {
  console.log(pc.bold('\nğŸš€ Deploying\n'));

  // Register resource providers (skip if already registered)
  console.log(pc.dim('  Checking Azure resource providers required for Container Apps...\n'));
  for (const provider of REQUIRED_PROVIDERS) {
    const state = tryRun(
      `az provider show --namespace ${provider} -o tsv --query registrationState 2>/dev/null`
    );
    if (state === 'Registered') {
      console.log(`  ${pc.green('âœ“')} ${provider} already registered`);
    } else {
      await runWithSpinner(
        `Registering ${provider}`,
        `az provider register --namespace ${provider} --wait`
      );
    }
  }
  console.log();

  // Create resource group if needed
  if (!resourceGroupExists(config.RESOURCE_GROUP)) {
    console.log(pc.dim(`  Creating resource group "${config.RESOURCE_GROUP}" in ${config.AZURE_REGION}...`));
    console.log(pc.dim('  This is the container for all deployed Azure resources.\n'));
    await runWithSpinner(
      `Creating resource group ${config.RESOURCE_GROUP}`,
      `az group create --name "${config.RESOURCE_GROUP}" --location "${config.AZURE_REGION}" -o none`
    );
  } else {
    console.log(pc.green('âœ“') + ` Resource group ${pc.cyan(config.RESOURCE_GROUP)} exists`);
  }
  console.log();

  // Deploy Bicep
  console.log(pc.dim('  Deploying infra/main.bicep â€” this creates or updates:\n'));
  console.log(pc.dim(`    â€¢ ${pc.white('Log Analytics Workspace')}  â†’ ${config.APP_NAME}-logs`));
  console.log(pc.dim(`      Collects container logs and metrics (PerGB2018 SKU, 30-day retention)`));
  console.log(pc.dim(`    â€¢ ${pc.white('Container Apps Environment')}  â†’ ${config.APP_NAME}-env`));
  console.log(pc.dim(`      Managed hosting environment connected to Log Analytics`));
  const containerImage = `ghcr.io/${config.GITHUB_OWNER}/${config.GITHUB_REPO}:${config.IMAGE_TAG}`.toLowerCase();
  console.log(pc.dim(`    â€¢ ${pc.white('Container App')}  â†’ ${config.APP_NAME}`));
  console.log(pc.dim(`      Runs ${containerImage}`));
  console.log(pc.dim(`      HTTPS ingress on port ${config.TARGET_PORT}, ${config.MIN_REPLICAS}â€“${config.MAX_REPLICAS} replicas (HTTP auto-scale)`));
  console.log(pc.dim(`      Resources: 0.25 vCPU, 0.5 Gi memory per replica\n`));

  const deployOutput = await runWithSpinner(
    'Deploying infra/main.bicep',
    [
      `az deployment group create`,
      `--resource-group "${config.RESOURCE_GROUP}"`,
      `--template-file "${BICEP_FILE}"`,
      `--parameters`,
      `appName="${config.APP_NAME}"`,
      `location="${config.AZURE_REGION}"`,
      `containerImage="${containerImage}"`,
      `targetPort=${config.TARGET_PORT}`,
      `minReplicas=${config.MIN_REPLICAS}`,
      `maxReplicas=${config.MAX_REPLICAS}`,
      `-o json`,
    ].join(' ')
  );

  // Show deployment outputs (FQDN + URL)
  let fqdn = '';
  try {
    const result = JSON.parse(deployOutput);
    const outputs = result?.properties?.outputs;
    if (outputs?.fqdn?.value) {
      fqdn = outputs.fqdn.value;
    }
    if (outputs?.url?.value) {
      console.log(`\n  ${pc.green('â†’')} App URL:    ${pc.cyan(pc.bold(outputs.url.value))}`);
    }
    if (fqdn) {
      console.log(`  ${pc.green('â†’')} FQDN:       ${pc.cyan(fqdn)}`);
    }
  } catch {
    // output parsing failed â€” non-critical
  }

  // Custom domain: Cloudflare DNS records + ACA binding
  if (config.CUSTOM_DOMAIN && config.CF_ZONE_ID && fqdn) {
    const repoSlug = `${config.GITHUB_OWNER}/${config.GITHUB_REPO}`;
    await configureDns(config.CUSTOM_DOMAIN, config.CF_ZONE_ID, fqdn, config.APP_NAME, config.RESOURCE_GROUP, repoSlug);
  }

  // OIDC federated credentials for GitHub Actions
  const setupOidc = await confirm({
    message: 'Set up OIDC credentials for GitHub Actions CI/CD?',
    default: true,
  });

  if (setupOidc) {
    const subscriptionId = run('az account show --query id -o tsv');
    const tenantId = run('az account show --query tenantId -o tsv');
    const spName = `github-actions-${config.APP_NAME}`;
    const repoSlug = `${config.GITHUB_OWNER}/${config.GITHUB_REPO}`;

    // Create or reuse service principal (no client secret â€” OIDC only)
    let clientId = tryRun(
      `az ad sp list --display-name "${spName}" --query "[0].appId" -o tsv 2>/dev/null`
    );

    if (clientId) {
      console.log(`  ${pc.green('âœ“')} Service principal ${pc.cyan(spName)} already exists`);
    } else {
      const spOutput = await runWithSpinner(
        `Creating service principal ${spName}`,
        `az ad sp create-for-rbac --name "${spName}" --role contributor --scopes /subscriptions/${subscriptionId}/resourceGroups/${config.RESOURCE_GROUP} --query appId -o tsv`
      );
      clientId = spOutput.trim();
    }

    // Add federated credential for main branch (idempotent â€” skip if exists)
    const appObjectId = run(`az ad app list --display-name "${spName}" --query "[0].id" -o tsv`);
    const fedCredName = `${config.GITHUB_REPO}-main`;
    const existingFedCred = tryRun(
      `az ad app federated-credential show --id "${appObjectId}" --federated-credential-id "${fedCredName}" 2>/dev/null`
    );

    if (existingFedCred) {
      console.log(`  ${pc.green('âœ“')} Federated credential ${pc.cyan(fedCredName)} already exists`);
    } else {
      const fedCredBody = JSON.stringify({
        name: fedCredName,
        issuer: 'https://token.actions.githubusercontent.com',
        subject: `repo:${repoSlug}:ref:refs/heads/main`,
        audiences: ['api://AzureADTokenExchange'],
      });

      await runWithSpinner(
        `Creating federated credential for ${repoSlug}:main`,
        `az ad app federated-credential create --id "${appObjectId}" --parameters '${fedCredBody}'`
      );
    }

    // Set GitHub secrets
    const secrets: Array<[string, string]> = [
      ['AZURE_CLIENT_ID', clientId!],
      ['AZURE_TENANT_ID', tenantId],
      ['AZURE_SUBSCRIPTION_ID', subscriptionId],
    ];

    for (const [name, value] of secrets) {
      const secretSpinner = createSpinner(`Setting ${name} secret`).start();
      try {
        await new Promise<void>((resolvePromise, reject) => {
          const child = spawn(
            'gh',
            ['secret', 'set', name, '--repo', repoSlug],
            { stdio: ['pipe', 'pipe', 'pipe'] }
          );
          child.stdin.write(value);
          child.stdin.end();
          child.on('close', (code) => (code === 0 ? resolvePromise() : reject(new Error(`gh secret set exited with code ${code}`))));
          child.on('error', reject);
        });
        secretSpinner.success({ text: `Setting ${name} secret` });
      } catch (err) {
        secretSpinner.error({ text: `Setting ${name} secret` });
        throw err;
      }
    }
  }

  console.log(pc.bold(pc.green('\nâœ… Deployment complete!\n')));
}

// â”€â”€â”€ DNS configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Configures custom domain DNS records and ACA hostname binding.
 * Extracted so it can be called from both the deploy flow and the standalone DNS option.
 * @param customDomain - The custom domain hostname (e.g. `"kota.dog"`).
 * @param cfZoneId - The Cloudflare zone ID.
 * @param fqdn - The Azure Container App FQDN to point DNS at.
 * @param appName - The container app name.
 * @param resourceGroup - The Azure resource group name.
 */
async function configureDns(
  customDomain: string, cfZoneId: string, fqdn: string,
  appName: string, resourceGroup: string, repoSlug: string,
): Promise<void> {
  console.log(pc.bold('\nğŸŒ Custom Domain Setup\n'));

  // Ensure we have a valid Cloudflare API token (prompts if needed)
  await ensureCfApiToken(repoSlug);

  const subdomain = customDomain.split('.').slice(0, -2).join('.') || '@';

  // Step A â€” CNAME record: create or update
  await upsertDnsRecord(cfZoneId, {
    type: 'CNAME',
    name: subdomain,
    content: fqdn,
    proxied: true,
    displayName: customDomain,
  });

  // Step B â€” TXT validation record for Azure (asuid.<subdomain>)
  const verificationId = tryRun(
    `az containerapp show --name "${appName}" -g "${resourceGroup}" --query "properties.customDomainVerificationId" -o tsv 2>/dev/null`
  );

  if (verificationId) {
    const txtName = subdomain === '@' ? 'asuid' : `asuid.${subdomain}`;
    await upsertDnsRecord(cfZoneId, {
      type: 'TXT',
      name: txtName,
      content: verificationId,
      proxied: false,
      displayName: `${txtName}.${rootDomain(customDomain)}`,
    });
  } else {
    console.log(pc.yellow('âš ') + ' Could not retrieve domain verification ID â€” TXT record skipped');
  }

  // Step C â€” ACA custom domain binding (skip if already bound)
  const detectedForDeploy = detectExistingApp(appName, resourceGroup);
  const domainAlreadyBound = detectedForDeploy?.customDomains.includes(customDomain) ?? false;

  if (domainAlreadyBound) {
    console.log(`  ${pc.green('âœ“')} Custom domain already bound: ${customDomain}`);
  } else {
    try {
      await runWithSpinner(
        `Adding hostname ${customDomain} to container app`,
        `az containerapp hostname add --name "${appName}" -g "${resourceGroup}" --hostname "${customDomain}"`
      );
      await runWithSpinner(
        `Binding TLS certificate for ${customDomain}`,
        `az containerapp hostname bind --name "${appName}" -g "${resourceGroup}" --hostname "${customDomain}" --environment "${appName}-env" --validation-method CNAME`
      );
    } catch (err) {
      console.log(pc.yellow('âš ') + ` Custom domain binding failed: ${err instanceof Error ? err.message : String(err)}`);
      console.log(pc.dim('  You may need to configure DNS and retry, or bind manually in the Azure portal.'));
    }
  }

  console.log(`\n  ${pc.green('â†’')} Custom URL: ${pc.cyan(pc.bold(`https://${customDomain}`))}`);

  // Offer to save CF API token as GitHub secret for CI/CD workflows
  if (cfApiToken && repoSlug) {
    const secretExists = tryRun(
      `gh secret list --repo ${repoSlug} --json name --jq '.[].name' 2>/dev/null`
    )?.split('\n').includes('CLOUDFLARE_API_TOKEN') ?? false;

    const saveLabel = secretExists
      ? 'Update CLOUDFLARE_API_TOKEN GitHub secret?'
      : 'Save CLOUDFLARE_API_TOKEN as a GitHub secret for CI/CD?';

    const saveToken = await confirm({ message: saveLabel, default: !secretExists });

    if (saveToken) {
      const tokenSpinner = createSpinner('Setting CLOUDFLARE_API_TOKEN secret').start();
      try {
        await new Promise<void>((resolvePromise, reject) => {
          const child = spawn(
            'gh',
            ['secret', 'set', 'CLOUDFLARE_API_TOKEN', '--repo', repoSlug],
            { stdio: ['pipe', 'pipe', 'pipe'] }
          );
          child.stdin.write(cfApiToken);
          child.stdin.end();
          child.on('close', (code) => (code === 0 ? resolvePromise() : reject(new Error(`gh secret set exited with code ${code}`))));
          child.on('error', reject);
        });
        tokenSpinner.success({ text: 'Setting CLOUDFLARE_API_TOKEN secret' });
      } catch (err) {
        tokenSpinner.error({ text: 'Setting CLOUDFLARE_API_TOKEN secret' });
        console.log(pc.yellow('âš ') + ` Failed to set secret: ${err instanceof Error ? err.message : String(err)}`);
      }
    }
  }
}

// â”€â”€â”€ Teardown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Tears down the Azure deployment by deleting the resource group and
 * optionally cleaning up the service principal and GitHub secrets.
 * Requires saved config to know what to delete.
 */
async function teardown(): Promise<void> {
  console.log(pc.bold(pc.red('\nğŸ—‘ï¸  Teardown Mode\n')));

  const saved = loadConfig();
  if (!saved.APP_NAME || !saved.RESOURCE_GROUP) {
    console.error(pc.red('  No saved configuration found. Nothing to tear down.'));
    console.error(pc.dim(`  Expected config at ${CONFIG_FILE}`));
    process.exit(1);
  }

  // Show what will be deleted
  console.log(pc.dim('  This will permanently delete:\n'));
  console.log(`    ${pc.red('â€¢')} Resource group ${pc.cyan(saved.RESOURCE_GROUP)} and ${pc.white('all resources inside it')}`);
  console.log(pc.dim('      (Container App, Container Apps Environment, Log Analytics Workspace)'));

  const detected = detectExistingApp(saved.APP_NAME, saved.RESOURCE_GROUP);
  if (detected) {
    console.log(pc.dim(`      Running app: ${detected.image}`));
    if (detected.fqdn) console.log(pc.dim(`      FQDN: ${detected.fqdn}`));
    if (detected.customDomains.length > 0) {
      console.log(pc.dim(`      Custom domains: ${detected.customDomains.join(', ')}`));
    }
  } else {
    console.log(pc.dim('      (resource group may already be deleted or app not found)'));
  }

  console.log();

  const confirmDelete = await confirm({
    message: `Delete resource group "${saved.RESOURCE_GROUP}" and all its resources?`,
    default: false,
  });

  if (!confirmDelete) {
    console.log(pc.dim('\n  Teardown cancelled.\n'));
    return;
  }

  // Double-confirm â€” this is destructive
  const doubleConfirm = await input({
    message: `Type "${saved.RESOURCE_GROUP}" to confirm deletion:`,
    validate: (v) => v.trim() === saved.RESOURCE_GROUP || 'Name does not match',
  });

  if (doubleConfirm.trim() !== saved.RESOURCE_GROUP) {
    console.log(pc.dim('\n  Teardown cancelled.\n'));
    return;
  }

  // Delete resource group
  await runWithSpinner(
    `Deleting resource group ${saved.RESOURCE_GROUP}`,
    `az group delete --name "${saved.RESOURCE_GROUP}" --yes --no-wait`
  );
  console.log(pc.dim('  Resource group deletion initiated (runs in background on Azure).\n'));

  // Optionally clean up service principal
  const spName = `github-actions-${saved.APP_NAME}`;
  const spAppId = tryRun(
    `az ad sp list --display-name "${spName}" --query "[0].appId" -o tsv 2>/dev/null`
  );

  if (spAppId) {
    const cleanupSp = await confirm({
      message: `Delete service principal "${spName}"?`,
      default: true,
    });

    if (cleanupSp) {
      await runWithSpinner(
        `Deleting service principal ${spName}`,
        `az ad app delete --id "${spAppId}"`
      );
    }
  }

  // Optionally clean up GitHub secrets
  if (saved.GITHUB_OWNER && saved.GITHUB_REPO) {
    const cleanupSecrets = await confirm({
      message: 'Remove OIDC secrets from GitHub repo?',
      default: true,
    });

    if (cleanupSecrets) {
      const repoSlug = `${saved.GITHUB_OWNER}/${saved.GITHUB_REPO}`;
      for (const secret of ['AZURE_CLIENT_ID', 'AZURE_TENANT_ID', 'AZURE_SUBSCRIPTION_ID']) {
        const result = tryRun(`gh secret delete ${secret} --repo ${repoSlug} 2>/dev/null`);
        if (result !== null) {
          console.log(`  ${pc.green('âœ“')} Deleted ${secret}`);
        }
      }
    }
  }

  console.log(pc.bold(pc.green('\nâœ… Teardown complete!\n')));
}

// â”€â”€â”€ Prompt flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Runs the full interactive prompt flow (repo, tag, region, app config, domain).
 * Extracted so it can be called from the detection-skip or normal path.
 * @param saved - Saved/merged config values to use as defaults.
 * @returns The full collected {@link Config}.
 */
async function runPromptFlow(saved: Partial<Config>): Promise<Config> {
  const [owner, repo] = await selectGithubRepo(saved);
  const imageTag = await selectImageTag(owner, repo, saved);
  const azureRegion = await selectAzureRegion(saved);
  const appConfig = await configureApp(saved);

  const repoSlug = `${owner}/${repo}`;
  const [customDomain, cfZoneId] = await configureCustomDomain(saved, repoSlug);

  return {
    GITHUB_OWNER: owner,
    GITHUB_REPO: repo,
    IMAGE_TAG: imageTag,
    AZURE_REGION: azureRegion,
    APP_NAME: appConfig.appName,
    RESOURCE_GROUP: appConfig.resourceGroup,
    TARGET_PORT: appConfig.targetPort,
    MIN_REPLICAS: appConfig.minReplicas,
    MAX_REPLICAS: appConfig.maxReplicas,
    CUSTOM_DOMAIN: customDomain,
    CF_ZONE_ID: cfZoneId,
  };
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Entry point for the setup wizard.
 * Orchestrates the full interactive flow: preflight checks, resource selection,
 * app configuration, config persistence, and deployment.
 */
async function main(): Promise<void> {
  console.log(pc.bold(pc.cyan('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—')));
  console.log(pc.bold(pc.cyan('â•‘   Azure Container Apps Setup Wizard      â•‘')));
  console.log(pc.bold(pc.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n')));

  // Load saved config
  const saved = loadConfig();
  if (Object.keys(saved).length > 0) {
    console.log(pc.dim(`  Loaded saved config from ${CONFIG_FILE}\n`));
  }

  // Step 1: Preflight
  preflight();

  // Step 2: Detect existing deployment
  let detected: DetectedApp | null = null;
  if (saved.APP_NAME && saved.RESOURCE_GROUP) {
    const spinner = createSpinner('Detecting existing deployment...').start();
    detected = detectExistingApp(saved.APP_NAME, saved.RESOURCE_GROUP);
    if (detected) {
      spinner.success({ text: `Found container app ${pc.cyan(saved.APP_NAME)} in rg ${pc.cyan(saved.RESOURCE_GROUP)} (${detected.region})` });
      console.log(pc.dim(`  Image:    ${detected.image}`));
      console.log(pc.dim(`  Port:     ${detected.targetPort}`));
      console.log(pc.dim(`  Replicas: ${detected.minReplicas}â€“${detected.maxReplicas}`));
      if (detected.fqdn) console.log(pc.dim(`  FQDN:     ${detected.fqdn}`));
      if (detected.customDomains.length > 0) {
        console.log(pc.dim(`  Domains:  ${detected.customDomains.join(', ')}`));
      }
      console.log();
    } else {
      spinner.warn({ text: `No existing app found for ${saved.APP_NAME} in ${saved.RESOURCE_GROUP}` });
      console.log();
    }
  }

  let config: Config;

  if (detected) {
    const menuChoices: Array<{ name: string; value: 'redeploy' | 'update' | 'dns' | 'delete' }> = [
      { name: 'Redeploy with current settings', value: 'redeploy' },
      { name: 'Update settings', value: 'update' },
      { name: 'Configure DNS only (skip deploy)', value: 'dns' },
      { name: pc.red('Delete stack'), value: 'delete' },
    ];

    const action = await select({
      message: 'Existing deployment found. What would you like to do?',
      choices: menuChoices,
    });
    console.log();

    if (action === 'delete') {
      await teardown();
      return;
    }

    if (action === 'dns') {
      // Configure DNS only â€” use detected FQDN, skip Bicep deploy
      const repoSlug = `${saved.GITHUB_OWNER ?? ''}/${saved.GITHUB_REPO ?? ''}`;
      const [customDomain, cfZoneId] = await configureCustomDomain(saved, repoSlug);
      if (customDomain && cfZoneId && detected.fqdn) {
        await configureDns(customDomain, cfZoneId, detected.fqdn, saved.APP_NAME!, saved.RESOURCE_GROUP!, repoSlug);
      } else {
        console.log(pc.dim('  No domain configured or FQDN unavailable.'));
      }
      return;
    }

    if (action === 'redeploy') {
      // Auto-populate config from detected values
      const parsed = parseGhcrImage(detected.image);
      config = {
        GITHUB_OWNER: parsed?.owner ?? saved.GITHUB_OWNER ?? '',
        GITHUB_REPO: parsed?.repo ?? saved.GITHUB_REPO ?? '',
        IMAGE_TAG: parsed?.tag ?? saved.IMAGE_TAG ?? 'latest',
        AZURE_REGION: detected.region || saved.AZURE_REGION || '',
        APP_NAME: saved.APP_NAME!,
        RESOURCE_GROUP: saved.RESOURCE_GROUP!,
        TARGET_PORT: detected.targetPort || saved.TARGET_PORT || '3000',
        MIN_REPLICAS: detected.minReplicas || saved.MIN_REPLICAS || '0',
        MAX_REPLICAS: detected.maxReplicas || saved.MAX_REPLICAS || '2',
        CUSTOM_DOMAIN: detected.customDomains[0] || saved.CUSTOM_DOMAIN || '',
        CF_ZONE_ID: saved.CF_ZONE_ID || '',
      };
    } else {
      // Fall through to prompts, but merge detected values as defaults
      const parsed = parseGhcrImage(detected.image);
      const mergedSaved: Partial<Config> = {
        ...saved,
        GITHUB_OWNER: parsed?.owner ?? saved.GITHUB_OWNER,
        GITHUB_REPO: parsed?.repo ?? saved.GITHUB_REPO,
        IMAGE_TAG: parsed?.tag ?? saved.IMAGE_TAG,
        AZURE_REGION: detected.region || saved.AZURE_REGION,
        TARGET_PORT: detected.targetPort || saved.TARGET_PORT,
        MIN_REPLICAS: detected.minReplicas || saved.MIN_REPLICAS,
        MAX_REPLICAS: detected.maxReplicas || saved.MAX_REPLICAS,
        CUSTOM_DOMAIN: detected.customDomains[0] || saved.CUSTOM_DOMAIN,
      };

      config = await runPromptFlow(mergedSaved);
    }
  } else {
    config = await runPromptFlow(saved);
  }

  // Save config
  saveConfig(config);
  console.log(pc.dim(`  Config saved to ${CONFIG_FILE}\n`));

  // Summary + confirm
  printSummary(config, detected);

  const proceed = await confirm({
    message: 'Deploy now?',
    default: true,
  });

  if (!proceed) {
    console.log(pc.dim('\n  Deployment cancelled. Config saved for next run.\n'));
    return;
  }

  // Step 9: Deploy
  await deploy(config);
}

// â”€â”€â”€ Entry point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const entrypoint = process.argv.includes('--teardown') ? teardown : main;

entrypoint().catch((err) => {
  // Handle Ctrl+C gracefully
  if (err instanceof Error && err.name === 'ExitPromptError') {
    console.log(pc.dim('\n  Cancelled.\n'));
    process.exit(0);
  }
  console.error(pc.red(`\n  Error: ${err instanceof Error ? err.message : String(err)}\n`));
  process.exit(1);
});
